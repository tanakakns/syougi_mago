{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/cp","compass.js","node_modules/clusterfck/lib/clusterfck.js","node_modules/clusterfck/lib/distance.js","node_modules/clusterfck/lib/hcluster.js","node_modules/clusterfck/lib/kmeans.js","node_modules/vega-lite/src/globals.js","src/cluster/cluster.js","src/cluster/clusterconsts.js","src/cluster/distance.js","src/consts.js","src/gen/aggregates.js","src/gen/encodings.js","src/gen/encs.js","src/gen/gen.js","src/gen/marktypes.js","src/gen/projections.js","src/globals.js","src/rank/rank.js","src/rank/rankEncodings.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","cp","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"consts","cluster","gen","rank","util","auto","./cluster/cluster","./consts","./gen/gen","./rank/rank","./util",2,"hcluster","Kmeans","kmeans","./hcluster","./kmeans",3,"euclidean","v1","v2","total","Math","pow","sqrt","manhattan","abs","max",4,"distances","HierarchicalClustering","distance","linkage","threshold","this","undefined","Infinity","prototype","items","snapshotPeriod","snapshotCb","clusters","dists","mins","index","value","key","size","j","dist","merged","mergeClosest","forEach","minKey","min","c1","c2","left","right","splice","ci","key1","key2","snapshot","snapshotCallback","./distance",5,"KMeans","centroids","randomCentroids","points","k","slice","sort","round","random","classify","point","ceil","assignment","Array","iterations","movement","assigned","push","centroid","newCentroid","g","sum","toJSON","JSON","stringify","fromJSON","json","parse","vectors",6,"TABLE","RAW","STACKED","INDEX","X","Y","ROW","COL","SIZE","SHAPE","COLOR","ALPHA","TEXT","DETAIL","N","O","Q","T",7,"encodings","opt","table","clusterTrees","clusterfck","e1","e2","s1","vl","Encoding","shorthand","s2","CLUSTER_THRESHOLD","map","tree","traverse","encoding1","encoding2","score","filter","cluster1","cluster2","../util","./clusterconsts",8,"reduceTupleToTable","x","b","d","c","SWAPPABLE","DIST_MISSING","DIST_BY_ENCTYPE","reduce",9,"len","colencs","getEncTypeByColumnName","shorthands","diff","sj","si","get","colenc1","colenc2","cols","union","keys","col","encType","isStack1","isStack","isStack2","encoding","color","name","_colenc","enc","duplicate","marktype",10,"projections","type","properties","omitDotPlot","default","description","maxCardinalityForAutoAddOrdinal","alwaysAddHistogram","aggregates","config","data","tableTypes","enum","genDimQ","minCardinalityForBin","omitMeasureOnly","omitDimensionOnly","addCountForDimensionOnly","aggrList","timeFnList","consistentAutoQ","marktypeList","encodingTypeList","maxGoodCardinalityForFacets","maxCardinalityForFacets","maxGoodCardinalityForColor","maxCardinalityForColor","maxCardinalityForShape","omitTranpose","omitDotPlotWithExtraEncoding","omitMultipleRetinalEncodings","omitNonTextAggrWithAllDimsOnFacets","omitSizeOnBar","omitStackedAverage","alwaysGenerateTableAsHeatmap",11,"genAggregates","output","fields","stats","emit","fieldSet","field","checkAndPush","hasMeasure","hasDimension","hasRaw","tf","isDimension","aggregate","count","pop","assignAggrQ","hasAggr","autoMode","canHaveAggr","cantHaveAggr","assignField","assignBinQ","bin","assignQ","_aggregate","_raw","_bin","ANY","isin","hasNorO","highCardinality","cardinality","isAuto","genBin","genCast","assignFnT","fn","assignT","_fn","schema","extend","any","isTypes","../consts",12,"genEncodingsFromFields","nested","encs","genEncs","dict","genEncodingsFromEncs","list","getMarktypes","markType","finalTouch","scoreFeatures","features","text","et","isMeasure","isCount","stat","stdev","avg","scale","zero","../rank/rank","./encs","./marktypes",13,"retinalEncRules","shape","alpha","colorRules","shapeRules","dimMeaTransposeRule","y","generalRules","genMarkTypes","satisfyRules","geo","arc","row","isAggrWithAllDimOnFacets","isDimX","isDimY","isAggregate","tmpEnc","isDim","rules","dimension","measure","multiple","detail","hasOtherO","../globals",14,"marktypes","charts","cfg","flat","getOpt","fieldSets","genAggr","level","nestedReduce","nestedMap","./aggregates","./encodings","./projections",15,"markTypes","vlmarktypes","facetRule","facetsRule","pointRule","xIsDim","yIsDim","tickRule","isOrdinalScale","barRule","lineRule","areaRule","textRule","marksRule","rule","bar","line","area","tick","mark","compile","marks","reqs","requiredEncoding","support","supportedEncoding",16,"selected","fieldsToAdd","hasSelectedDimension","hasSelectedMeasure","indices","compareFieldsToAdd","setsToAdd","chooseKorLess","setToAdd","concat","typeIsMeasureScore","projection","join",17,"CHART_TYPES","BAR","PLOT","LINE","AREA","MAP","HISTOGRAM","ANY_DATA_TYPES","vega-lite/src/globals",18,"./rankEncodings",19,"rankEncodings","encTypes","encodingMappingByField","mappings","reasons","m","assign","scores","role","reason","apply","UNUSED_POSITION","MARK_SCORE","p","circle","square","D","M","BAD","TERRIBLE","minor","pos","Y_T","facet_text","facet_good","facet_ok","facet_bad","color_good","color_ok","color_bad","color_stack","bad","terrible","dimensionScore","hasOrder","isStacked","measureScore",20,"isArray","obj","toString","sp","v","nonEmpty","grp","node","arr","Object","create","DEFAULT_OPT","powerset","ps","subset","sub","chooseK","kArray","cross"],"mappings":"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","file":"compass.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.cp=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n\n},{\"./cluster/cluster\":7,\"./consts\":10,\"./gen/gen\":14,\"./rank/rank\":18,\"./util\":20}],2:[function(require,module,exports){\nmodule.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};\n},{\"./hcluster\":4,\"./kmeans\":5}],3:[function(require,module,exports){\nmodule.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};\n},{}],4:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n\n},{\"./distance\":3}],5:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}\n},{\"./distance\":3}],6:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],7:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2.score - encoding1.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0].score - cluster1[0].score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":20,\"./clusterconsts\":8,\"./distance\":9,\"clusterfck\":2}],8:[function(require,module,exports){\n'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['color', 'alpha', c.SWAPPABLE],\n  ['size', 'alpha', c.SWAPPABLE],\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n\n},{}],9:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.encoding.color.name !== colenc2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.encoding;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    encoding: encoding.encoding\n  };\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":20,\"./clusterconsts\":8}],10:[function(require,module,exports){\n'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'avg']\n    },\n    timeFnList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, alpha, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n\n},{}],11:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar consts = require('../consts');\n\nvar ANY='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasNorO = vl.any(fields, function(f) {\n    return vl.field.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.field.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.field.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.field.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === ANY || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [ANY, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.field.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [ANY, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [ANY, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignFnT(i, hasAggr, autoMode, fn) {\n    tf[i].fn = fn;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].fn;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._fns\n    if (f._fn) {\n      assignFnT(i, hasAggr, autoMode, f._fn);\n    } else {\n      opt.timeFnList.forEach(function(fn) {\n        if (fn === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignFnT(i, hasAggr, autoMode, fn);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, ANY);\n\n  return output;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":10}],12:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          data: opt.data,\n          marktype: markType,\n          encoding: enc,\n          config: opt.config\n        }),\n        encoding = finalTouch(e, stats, opt),\n        score = rank.encoding(encoding, stats, opt);\n\n      encoding.score = score.score;\n      encoding.scoreFeatures = score.features;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.encoding.color = encoding.encoding.text;\n  }\n\n  // don't include zero if stdev/avg < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.encoding;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.field.isMeasure(field) && !vl.field.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.avg < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":10,\"../rank/rank\":18,\"./encs\":13,\"./marktypes\":15}],13:[function(require,module,exports){\n(function (global){\n\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.field.isDimension,\n  isMeasure = vl.field.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  alpha: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape || enc.alpha) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.field.isMeasure(field) ||\n    vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === Q) return false;\n  if (field.fn && field.type === T) return false;\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (vl.field.isTypes(enc.y, [N, O]) && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (!vl.field.isTypes(enc.x, [N, O]) && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type===T || enc.x.type === T) {\n          if (enc.y.type===T && enc.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggregate == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggregate == 'count' && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.field.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":10,\"../globals\":17,\"./marktypes\":15}],14:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n},{\"../util\":20,\"./aggregates\":11,\"./encodings\":12,\"./encs\":13,\"./marktypes\":15,\"./projections\":16}],15:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  isDimension = vl.field.isDimension,\n  isOrdinalScale = vl.field.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n\n  var markTypes = opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n\n  return markTypes;\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compile.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // need to aggregate on either x or y\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  if (((enc.x.aggregate !== undefined) ^ (enc.y.aggregate !== undefined)) &&\n      (isDimension(enc.x) ^ isDimension(enc.y))) {\n\n    var aggregate = enc.x.aggregate || enc.y.aggregate;\n    return !(opt.omitStackedAverage && aggregate ==='avg' && enc.color);\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.fn && enc.y.type == 'Q' && enc.y.aggregate;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggregate ==='avg' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggregate && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":10}],16:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.field.isCount(field)) {\n      if (vl.field.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.field.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 1,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.field.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":10,\"../util\":20}],17:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"vega-lite/src/globals\":6}],18:[function(require,module,exports){\nmodule.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n\n},{\"./rankEncodings\":19}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.encoding),\n    marktype = encoding.marktype,\n    enc = encoding.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.encoding, function(o, field, encType) {\n    var key = vl.field.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.field.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.field.role(m.field);\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.alpha = 0.45;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.field.cardinality(field, stats);\n  switch (encType) {\n    case X:\n      if (vl.field.isTypes(field, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.field.isTypes(field, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (field.bin && field.type===Q) || (field.fn && field.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case 'alpha': return M.alpha;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../globals\":17}],20:[function(require,module,exports){\n\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n\n},{\"./consts\":10}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY3AiLCJub2RlX21vZHVsZXMvY2x1c3RlcmZjay9saWIvY2x1c3RlcmZjay5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9kaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9oY2x1c3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9rbWVhbnMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL3NyYy9nbG9iYWxzLmpzIiwic3JjL2NsdXN0ZXIvY2x1c3Rlci5qcyIsInNyYy9jbHVzdGVyL2NsdXN0ZXJjb25zdHMuanMiLCJzcmMvY2x1c3Rlci9kaXN0YW5jZS5qcyIsInNyYy9jb25zdHMuanMiLCJzcmMvZ2VuL2FnZ3JlZ2F0ZXMuanMiLCJzcmMvZ2VuL2VuY29kaW5ncy5qcyIsInNyYy9nZW4vZW5jcy5qcyIsInNyYy9nZW4vZ2VuLmpzIiwic3JjL2dlbi9tYXJrdHlwZXMuanMiLCJzcmMvZ2VuL3Byb2plY3Rpb25zLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvcmFuay9yYW5rLmpzIiwic3JjL3JhbmsvcmFua0VuY29kaW5ncy5qcyIsInNyYy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdHM6IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIGNsdXN0ZXI6IHJlcXVpcmUoJy4vY2x1c3Rlci9jbHVzdGVyJyksXG4gIGdlbjogcmVxdWlyZSgnLi9nZW4vZ2VuJyksXG4gIHJhbms6IHJlcXVpcmUoJy4vcmFuay9yYW5rJyksXG4gIHV0aWw6IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBhdXRvOiBcIi0sIHN1bVwiXG59O1xuXG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgaGNsdXN0ZXI6IHJlcXVpcmUoXCIuL2hjbHVzdGVyXCIpLFxuICAgS21lYW5zOiByZXF1aXJlKFwiLi9rbWVhbnNcIiksXG4gICBrbWVhbnM6IHJlcXVpcmUoXCIuL2ttZWFuc1wiKS5rbWVhbnNcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdG90YWwgKz0gTWF0aC5wb3codjJbaV0gLSB2MVtpXSwgMik7ICAgICAgXG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRvdGFsKTtcbiAgIH0sXG4gICBtYW5oYXR0YW46IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICB2YXIgdG90YWwgPSAwO1xuICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aCA7IGkrKykge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2MltpXSAtIHYxW2ldKTsgICAgICBcbiAgICAgfVxuICAgICByZXR1cm4gdG90YWw7XG4gICB9LFxuICAgbWF4OiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgdmFyIG1heCA9IDA7XG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4ICwgTWF0aC5hYnModjJbaV0gLSB2MVtpXSkpOyAgICAgIFxuICAgICB9XG4gICAgIHJldHVybiBtYXg7XG4gICB9XG59OyIsInZhciBkaXN0YW5jZXMgPSByZXF1aXJlKFwiLi9kaXN0YW5jZVwiKTtcblxudmFyIEhpZXJhcmNoaWNhbENsdXN0ZXJpbmcgPSBmdW5jdGlvbihkaXN0YW5jZSwgbGlua2FnZSwgdGhyZXNob2xkKSB7XG4gICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICB0aGlzLmxpbmthZ2UgPSBsaW5rYWdlO1xuICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQgPT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB0aHJlc2hvbGQ7XG59XG5cbkhpZXJhcmNoaWNhbENsdXN0ZXJpbmcucHJvdG90eXBlID0ge1xuICAgY2x1c3RlciA6IGZ1bmN0aW9uKGl0ZW1zLCBzbmFwc2hvdFBlcmlvZCwgc25hcHNob3RDYikge1xuICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgdGhpcy5kaXN0cyA9IFtdOyAgLy8gZGlzdGFuY2VzIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG4gICAgICB0aGlzLm1pbnMgPSBbXTsgLy8gY2xvc2VzdCBjbHVzdGVyIGZvciBlYWNoIGNsdXN0ZXJcbiAgICAgIHRoaXMuaW5kZXggPSBbXTsgLy8ga2VlcCBhIGhhc2ggb2YgYWxsIGNsdXN0ZXJzIGJ5IGtleVxuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB2YXIgY2x1c3RlciA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtc1tpXSxcbiAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc2l6ZTogMVxuICAgICAgICAgfTtcbiAgICAgICAgIHRoaXMuY2x1c3RlcnNbaV0gPSBjbHVzdGVyO1xuICAgICAgICAgdGhpcy5pbmRleFtpXSA9IGNsdXN0ZXI7XG4gICAgICAgICB0aGlzLmRpc3RzW2ldID0gW107XG4gICAgICAgICB0aGlzLm1pbnNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSAoaSA9PSBqKSA/IEluZmluaXR5IDogXG4gICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlKHRoaXMuY2x1c3RlcnNbaV0udmFsdWUsIHRoaXMuY2x1c3RlcnNbal0udmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kaXN0c1tpXVtqXSA9IGRpc3Q7XG4gICAgICAgICAgICB0aGlzLmRpc3RzW2pdW2ldID0gZGlzdDtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCB0aGlzLmRpc3RzW2ldW3RoaXMubWluc1tpXV0pIHtcbiAgICAgICAgICAgICAgIHRoaXMubWluc1tpXSA9IGo7ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXJnZWQgPSB0aGlzLm1lcmdlQ2xvc2VzdCgpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKG1lcmdlZCkge1xuICAgICAgICBpZiAoc25hcHNob3RDYiAmJiAoaSsrICUgc25hcHNob3RQZXJpb2QpID09IDApIHtcbiAgICAgICAgICAgc25hcHNob3RDYih0aGlzLmNsdXN0ZXJzKTsgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIG1lcmdlZCA9IHRoaXMubWVyZ2VDbG9zZXN0KCk7XG4gICAgICB9XG4gICAgXG4gICAgICB0aGlzLmNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24oY2x1c3Rlcikge1xuICAgICAgICAvLyBjbGVhbiB1cCBtZXRhZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gICAgICAgIGRlbGV0ZSBjbHVzdGVyLmtleTtcbiAgICAgICAgZGVsZXRlIGNsdXN0ZXIuaW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcnM7XG4gICB9LFxuICBcbiAgIG1lcmdlQ2xvc2VzdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBmaW5kIHR3byBjbG9zZXN0IGNsdXN0ZXJzIGZyb20gY2FjaGVkIG1pbnNcbiAgICAgIHZhciBtaW5LZXkgPSAwLCBtaW4gPSBJbmZpbml0eTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGtleSA9IHRoaXMuY2x1c3RlcnNbaV0ua2V5LFxuICAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2tleV1bdGhpcy5taW5zW2tleV1dO1xuICAgICAgICAgaWYgKGRpc3QgPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbktleSA9IGtleTtcbiAgICAgICAgICAgIG1pbiA9IGRpc3Q7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWluID49IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7ICAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIHZhciBjMSA9IHRoaXMuaW5kZXhbbWluS2V5XSxcbiAgICAgICAgICBjMiA9IHRoaXMuaW5kZXhbdGhpcy5taW5zW21pbktleV1dO1xuXG4gICAgICAvLyBtZXJnZSB0d28gY2xvc2VzdCBjbHVzdGVyc1xuICAgICAgdmFyIG1lcmdlZCA9IHtcbiAgICAgICAgIGxlZnQ6IGMxLFxuICAgICAgICAgcmlnaHQ6IGMyLFxuICAgICAgICAga2V5OiBjMS5rZXksXG4gICAgICAgICBzaXplOiBjMS5zaXplICsgYzIuc2l6ZVxuICAgICAgfTtcblxuICAgICAgdGhpcy5jbHVzdGVyc1tjMS5pbmRleF0gPSBtZXJnZWQ7XG4gICAgICB0aGlzLmNsdXN0ZXJzLnNwbGljZShjMi5pbmRleCwgMSk7XG4gICAgICB0aGlzLmluZGV4W2MxLmtleV0gPSBtZXJnZWQ7XG5cbiAgICAgIC8vIHVwZGF0ZSBkaXN0YW5jZXMgd2l0aCBuZXcgbWVyZ2VkIGNsdXN0ZXJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGNpID0gdGhpcy5jbHVzdGVyc1tpXTtcbiAgICAgICAgIHZhciBkaXN0O1xuICAgICAgICAgaWYgKGMxLmtleSA9PSBjaS5rZXkpIHtcbiAgICAgICAgICAgIGRpc3QgPSBJbmZpbml0eTsgICAgICAgICAgICBcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2UgaWYgKHRoaXMubGlua2FnZSA9PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV07XG4gICAgICAgICAgICBpZiAodGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV0gPiB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XSkge1xuICAgICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5saW5rYWdlID09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldIDwgdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV0pIHtcbiAgICAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XTsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5saW5rYWdlID09IFwiYXZlcmFnZVwiKSB7XG4gICAgICAgICAgICBkaXN0ID0gKHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldICogYzEuc2l6ZVxuICAgICAgICAgICAgICAgICAgICsgdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV0gKiBjMi5zaXplKSAvIChjMS5zaXplICsgYzIuc2l6ZSk7XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RhbmNlKGNpLnZhbHVlLCBjMS52YWx1ZSk7ICAgICAgICAgICAgXG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuZGlzdHNbYzEua2V5XVtjaS5rZXldID0gdGhpcy5kaXN0c1tjaS5rZXldW2MxLmtleV0gPSBkaXN0O1xuICAgICAgfVxuXG4gICAgXG4gICAgICAvLyB1cGRhdGUgY2FjaGVkIG1pbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdmFyIGtleTEgPSB0aGlzLmNsdXN0ZXJzW2ldLmtleTsgICAgICAgIFxuICAgICAgICAgaWYgKHRoaXMubWluc1trZXkxXSA9PSBjMS5rZXkgfHwgdGhpcy5taW5zW2tleTFdID09IGMyLmtleSkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IGtleTE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgIHZhciBrZXkyID0gdGhpcy5jbHVzdGVyc1tqXS5rZXk7XG4gICAgICAgICAgICAgICBpZiAodGhpcy5kaXN0c1trZXkxXVtrZXkyXSA8IHRoaXMuZGlzdHNba2V5MV1bbWluXSkge1xuICAgICAgICAgICAgICAgICAgbWluID0ga2V5MjsgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWluc1trZXkxXSA9IG1pbjtcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuY2x1c3RlcnNbaV0uaW5kZXggPSBpO1xuICAgICAgfVxuICAgIFxuICAgICAgLy8gY2xlYW4gdXAgbWV0YWRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgZGVsZXRlIGMxLmtleTsgZGVsZXRlIGMyLmtleTtcbiAgICAgIGRlbGV0ZSBjMS5pbmRleDsgZGVsZXRlIGMyLmluZGV4O1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbn1cblxudmFyIGhjbHVzdGVyID0gZnVuY3Rpb24oaXRlbXMsIGRpc3RhbmNlLCBsaW5rYWdlLCB0aHJlc2hvbGQsIHNuYXBzaG90LCBzbmFwc2hvdENhbGxiYWNrKSB7XG4gICBkaXN0YW5jZSA9IGRpc3RhbmNlIHx8IFwiZXVjbGlkZWFuXCI7XG4gICBsaW5rYWdlID0gbGlua2FnZSB8fCBcImF2ZXJhZ2VcIjtcblxuICAgaWYgKHR5cGVvZiBkaXN0YW5jZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgIGRpc3RhbmNlID0gZGlzdGFuY2VzW2Rpc3RhbmNlXTtcbiAgIH1cbiAgIHZhciBjbHVzdGVycyA9IChuZXcgSGllcmFyY2hpY2FsQ2x1c3RlcmluZyhkaXN0YW5jZSwgbGlua2FnZSwgdGhyZXNob2xkKSlcbiAgICAgICAgICAgICAgICAgIC5jbHVzdGVyKGl0ZW1zLCBzbmFwc2hvdCwgc25hcHNob3RDYWxsYmFjayk7XG4gICAgICBcbiAgIGlmICh0aHJlc2hvbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNsdXN0ZXJzWzBdOyAvLyBhbGwgY2x1c3RlcmVkIGludG8gb25lXG4gICB9XG4gICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGNsdXN0ZXI7XG4iLCJ2YXIgZGlzdGFuY2VzID0gcmVxdWlyZShcIi4vZGlzdGFuY2VcIik7XG5cbmZ1bmN0aW9uIEtNZWFucyhjZW50cm9pZHMpIHtcbiAgIHRoaXMuY2VudHJvaWRzID0gY2VudHJvaWRzIHx8IFtdO1xufVxuXG5LTWVhbnMucHJvdG90eXBlLnJhbmRvbUNlbnRyb2lkcyA9IGZ1bmN0aW9uKHBvaW50cywgaykge1xuICAgdmFyIGNlbnRyb2lkcyA9IHBvaW50cy5zbGljZSgwKTsgLy8gY29weVxuICAgY2VudHJvaWRzLnNvcnQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSkgLSAwLjUpO1xuICAgfSk7XG4gICByZXR1cm4gY2VudHJvaWRzLnNsaWNlKDAsIGspO1xufVxuXG5LTWVhbnMucHJvdG90eXBlLmNsYXNzaWZ5ID0gZnVuY3Rpb24ocG9pbnQsIGRpc3RhbmNlKSB7XG4gICB2YXIgbWluID0gSW5maW5pdHksXG4gICAgICAgaW5kZXggPSAwO1xuXG4gICBkaXN0YW5jZSA9IGRpc3RhbmNlIHx8IFwiZXVjbGlkZWFuXCI7XG4gICBpZiAodHlwZW9mIGRpc3RhbmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRpc3RhbmNlID0gZGlzdGFuY2VzW2Rpc3RhbmNlXTtcbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNlbnRyb2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShwb2ludCwgdGhpcy5jZW50cm9pZHNbaV0pO1xuICAgICAgaWYgKGRpc3QgPCBtaW4pIHtcbiAgICAgICAgIG1pbiA9IGRpc3Q7XG4gICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICB9XG5cbiAgIHJldHVybiBpbmRleDtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5jbHVzdGVyID0gZnVuY3Rpb24ocG9pbnRzLCBrLCBkaXN0YW5jZSwgc25hcHNob3RQZXJpb2QsIHNuYXBzaG90Q2IpIHtcbiAgIGsgPSBrIHx8IE1hdGgubWF4KDIsIE1hdGguY2VpbChNYXRoLnNxcnQocG9pbnRzLmxlbmd0aCAvIDIpKSk7XG5cbiAgIGRpc3RhbmNlID0gZGlzdGFuY2UgfHwgXCJldWNsaWRlYW5cIjtcbiAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT0gXCJzdHJpbmdcIikge1xuICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZXNbZGlzdGFuY2VdO1xuICAgfVxuXG4gICB0aGlzLmNlbnRyb2lkcyA9IHRoaXMucmFuZG9tQ2VudHJvaWRzKHBvaW50cywgayk7XG5cbiAgIHZhciBhc3NpZ25tZW50ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGgpO1xuICAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KGspO1xuXG4gICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICB2YXIgbW92ZW1lbnQgPSB0cnVlO1xuICAgd2hpbGUgKG1vdmVtZW50KSB7XG4gICAgICAvLyB1cGRhdGUgcG9pbnQtdG8tY2VudHJvaWQgYXNzaWdubWVudHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICBhc3NpZ25tZW50W2ldID0gdGhpcy5jbGFzc2lmeShwb2ludHNbaV0sIGRpc3RhbmNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIGxvY2F0aW9uIG9mIGVhY2ggY2VudHJvaWRcbiAgICAgIG1vdmVtZW50ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgICAgdmFyIGFzc2lnbmVkID0gW107XG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzc2lnbm1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhc3NpZ25tZW50W2ldID09IGopIHtcbiAgICAgICAgICAgICAgIGFzc2lnbmVkLnB1c2gocG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKCFhc3NpZ25lZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgfVxuXG4gICAgICAgICB2YXIgY2VudHJvaWQgPSB0aGlzLmNlbnRyb2lkc1tqXTtcbiAgICAgICAgIHZhciBuZXdDZW50cm9pZCA9IG5ldyBBcnJheShjZW50cm9pZC5sZW5ndGgpO1xuXG4gICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGNlbnRyb2lkLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXNzaWduZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgIHN1bSArPSBhc3NpZ25lZFtpXVtnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0NlbnRyb2lkW2ddID0gc3VtIC8gYXNzaWduZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobmV3Q2VudHJvaWRbZ10gIT0gY2VudHJvaWRbZ10pIHtcbiAgICAgICAgICAgICAgIG1vdmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5jZW50cm9pZHNbal0gPSBuZXdDZW50cm9pZDtcbiAgICAgICAgIGNsdXN0ZXJzW2pdID0gYXNzaWduZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbmFwc2hvdENiICYmIChpdGVyYXRpb25zKysgJSBzbmFwc2hvdFBlcmlvZCA9PSAwKSkge1xuICAgICAgICAgc25hcHNob3RDYihjbHVzdGVycyk7XG4gICAgICB9XG4gICB9XG5cbiAgIHJldHVybiBjbHVzdGVycztcbn1cblxuS01lYW5zLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmNlbnRyb2lkcyk7XG59XG5cbktNZWFucy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbihqc29uKSB7XG4gICB0aGlzLmNlbnRyb2lkcyA9IEpTT04ucGFyc2UoanNvbik7XG4gICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBLTWVhbnM7XG5cbm1vZHVsZS5leHBvcnRzLmttZWFucyA9IGZ1bmN0aW9uKHZlY3RvcnMsIGspIHtcbiAgIHJldHVybiAobmV3IEtNZWFucygpKS5jbHVzdGVyKHZlY3RvcnMsIGspO1xufSIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5UQUJMRSA9ICd0YWJsZSc7XG5nLlJBVyA9ICdyYXcnO1xuZy5TVEFDS0VEID0gJ3N0YWNrZWQnO1xuZy5JTkRFWCA9ICdpbmRleCc7XG5cbmcuWCA9ICd4JztcbmcuWSA9ICd5JztcbmcuUk9XID0gJ3Jvdyc7XG5nLkNPTCA9ICdjb2wnO1xuZy5TSVpFID0gJ3NpemUnO1xuZy5TSEFQRSA9ICdzaGFwZSc7XG5nLkNPTE9SID0gJ2NvbG9yJztcbmcuQUxQSEEgPSAnYWxwaGEnO1xuZy5URVhUID0gJ3RleHQnO1xuZy5ERVRBSUwgPSAnZGV0YWlsJztcblxuZy5OID0gJ04nO1xuZy5PID0gJ08nO1xuZy5RID0gJ1EnO1xuZy5UID0gJ1QnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gY2x1c3RlcjtcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCksXG4gIGNsdXN0ZXJmY2sgPSByZXF1aXJlKCdjbHVzdGVyZmNrJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4vY2x1c3RlcmNvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5jbHVzdGVyLmRpc3RhbmNlID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpO1xuXG5mdW5jdGlvbiBjbHVzdGVyKGVuY29kaW5ncywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIGRpc3QgPSBjbHVzdGVyLmRpc3RhbmNlLnRhYmxlKGVuY29kaW5ncyk7XG5cbiAgdmFyIGNsdXN0ZXJUcmVlcyA9IGNsdXN0ZXJmY2suaGNsdXN0ZXIoZW5jb2RpbmdzLCBmdW5jdGlvbihlMSwgZTIpIHtcbiAgICB2YXIgczEgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQoZTEpLFxuICAgICAgczIgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQoZTIpO1xuICAgIHJldHVybiBkaXN0W3MxXVtzMl07XG4gIH0sICdhdmVyYWdlJywgY29uc3RzLkNMVVNURVJfVEhSRVNIT0xEKTtcblxuICB2YXIgY2x1c3RlcnMgPSBjbHVzdGVyVHJlZXMubWFwKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyYXZlcnNlKHRyZWUsIFtdKTtcbiAgICB9KVxuICAgLm1hcChmdW5jdGlvbihjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXIuc29ydChmdW5jdGlvbihlbmNvZGluZzEsIGVuY29kaW5nMikge1xuICAgICAgLy8gc29ydCBlYWNoIGNsdXN0ZXIgLS0gaGF2ZSB0aGUgaGlnaGVzdCBzY29yZSBhcyAxc3QgaXRlbVxuICAgICAgcmV0dXJuIGVuY29kaW5nMi5zY29yZSAtIGVuY29kaW5nMS5zY29yZTtcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGNsdXN0ZXIpIHsgIC8vIGZpbHRlciBlbXB0eSBjbHVzdGVyXG4gICAgcmV0dXJuIGNsdXN0ZXIubGVuZ3RoID4wO1xuICB9KS5zb3J0KGZ1bmN0aW9uKGNsdXN0ZXIxLCBjbHVzdGVyMikge1xuICAgIC8vc29ydCBieSBoaWdoZXN0IHNjb3JpbmcgaXRlbSBpbiBlYWNoIGNsdXN0ZXJcbiAgICByZXR1cm4gY2x1c3RlcjJbMF0uc2NvcmUgLSBjbHVzdGVyMVswXS5zY29yZTtcbiAgfSk7XG5cbiAgY2x1c3RlcnMuZGlzdCA9IGRpc3Q7IC8vYXBwZW5kIGRpc3QgaW4gdGhlIGFycmF5IGZvciBkZWJ1Z2dpbmdcblxuICByZXR1cm4gY2x1c3RlcnM7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmMuU1dBUFBBQkxFID0gMC4wNTtcbmMuRElTVF9NSVNTSU5HID0gMTtcbmMuQ0xVU1RFUl9USFJFU0hPTEQgPSAxO1xuXG5mdW5jdGlvbiByZWR1Y2VUdXBsZVRvVGFibGUociwgeCkge1xuICB2YXIgYSA9IHhbMF0sIGIgPSB4WzFdLCBkID0geFsyXTtcbiAgclthXSA9IHJbYV0gfHwge307XG4gIHJbYl0gPSByW2JdIHx8IHt9O1xuICByW2FdW2JdID0gcltiXVthXSA9IGQ7XG4gIHJldHVybiByO1xufVxuXG5jLkRJU1RfQllfRU5DVFlQRSA9IFtcbiAgLy8gcG9zaXRpb25hbFxuICBbJ3gnLCAneScsIGMuU1dBUFBBQkxFXSxcbiAgWydyb3cnLCAnY29sJywgYy5TV0FQUEFCTEVdLFxuXG4gIC8vIG9yZGluYWwgbWFyayBwcm9wZXJ0aWVzXG4gIFsnY29sb3InLCAnc2hhcGUnLCBjLlNXQVBQQUJMRV0sXG4gIFsnY29sb3InLCAnZGV0YWlsJywgYy5TV0FQUEFCTEVdLFxuICBbJ2RldGFpbCcsICdzaGFwZScsIGMuU1dBUFBBQkxFXSxcblxuICAvLyBxdWFudGl0YXRpdmUgbWFyayBwcm9wZXJ0aWVzXG4gIFsnY29sb3InLCAnYWxwaGEnLCBjLlNXQVBQQUJMRV0sXG4gIFsnc2l6ZScsICdhbHBoYScsIGMuU1dBUFBBQkxFXSxcbiAgWydzaXplJywgJ2NvbG9yJywgYy5TV0FQUEFCTEVdXG5dLnJlZHVjZShyZWR1Y2VUdXBsZVRvVGFibGUsIHt9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4vY2x1c3RlcmNvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgZGlzdGFuY2UgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbmRpc3RhbmNlLnRhYmxlID0gZnVuY3Rpb24gKGVuY29kaW5ncykge1xuICB2YXIgbGVuID0gZW5jb2RpbmdzLmxlbmd0aCxcbiAgICBjb2xlbmNzID0gZW5jb2RpbmdzLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBkaXN0YW5jZS5nZXRFbmNUeXBlQnlDb2x1bW5OYW1lKGUpOyB9KSxcbiAgICBzaG9ydGhhbmRzID0gZW5jb2RpbmdzLm1hcCh2bC5FbmNvZGluZy5zaG9ydGhhbmQpLFxuICAgIGRpZmYgPSB7fSwgaSwgajtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIGRpZmZbc2hvcnRoYW5kc1tpXV0gPSB7fTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgc2ogPSBzaG9ydGhhbmRzW2pdLCBzaSA9IHNob3J0aGFuZHNbaV07XG5cbiAgICAgIGRpZmZbc2pdW3NpXSA9IGRpZmZbc2ldW3NqXSA9IGRpc3RhbmNlLmdldChjb2xlbmNzW2ldLCBjb2xlbmNzW2pdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59O1xuXG5kaXN0YW5jZS5nZXQgPSBmdW5jdGlvbiAoY29sZW5jMSwgY29sZW5jMikge1xuICB2YXIgY29scyA9IHV0aWwudW5pb24odmwua2V5cyhjb2xlbmMxLmNvbCksIHZsLmtleXMoY29sZW5jMi5jb2wpKSxcbiAgICBkaXN0ID0gMDtcblxuICBjb2xzLmZvckVhY2goZnVuY3Rpb24oY29sKSB7XG4gICAgdmFyIGUxID0gY29sZW5jMS5jb2xbY29sXSwgZTIgPSBjb2xlbmMyLmNvbFtjb2xdO1xuXG4gICAgaWYgKGUxICYmIGUyKSB7XG4gICAgICBpZiAoZTEuZW5jVHlwZSAhPSBlMi5lbmNUeXBlKSB7XG4gICAgICAgIGRpc3QgKz0gKGNvbnN0cy5ESVNUX0JZX0VOQ1RZUEVbZTEuZW5jVHlwZV0gfHwge30pW2UyLmVuY1R5cGVdIHx8IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3QgKz0gY29uc3RzLkRJU1RfTUlTU0lORztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGRvIG5vdCBncm91cCBzdGFja2VkIGNoYXJ0IHdpdGggc2ltaWxhciBub24tc3RhY2tlZCBjaGFydCFcbiAgdmFyIGlzU3RhY2sxID0gdmwuRW5jb2RpbmcuaXNTdGFjayhjb2xlbmMxKSxcbiAgICBpc1N0YWNrMiA9IHZsLkVuY29kaW5nLmlzU3RhY2soY29sZW5jMik7XG5cbiAgaWYoaXNTdGFjazEgfHwgaXNTdGFjazIpIHtcbiAgICBpZihpc1N0YWNrMSAmJiBpc1N0YWNrMikge1xuICAgICAgaWYoY29sZW5jMS5lbmNvZGluZy5jb2xvci5uYW1lICE9PSBjb2xlbmMyLmVuY29kaW5nLmNvbG9yLm5hbWUpIHtcbiAgICAgICAgZGlzdCs9MTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzdCs9MTsgLy8gc3VyZWx5IGRpZmZlcmVudFxuICAgIH1cbiAgfVxuICByZXR1cm4gZGlzdDtcbn07XG5cbi8vIGdldCBlbmNvZGluZyB0eXBlIGJ5IGZpZWxkbmFtZVxuZGlzdGFuY2UuZ2V0RW5jVHlwZUJ5Q29sdW1uTmFtZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBfY29sZW5jID0ge30sXG4gICAgZW5jID0gZW5jb2RpbmcuZW5jb2Rpbmc7XG5cbiAgdmwua2V5cyhlbmMpLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHZhciBlID0gdmwuZHVwbGljYXRlKGVuY1tlbmNUeXBlXSk7XG4gICAgZS5lbmNUeXBlID0gZW5jVHlwZTtcbiAgICBfY29sZW5jW2UubmFtZSB8fCAnJ10gPSBlO1xuICAgIGRlbGV0ZSBlLm5hbWU7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbWFya3R5cGU6IGVuY29kaW5nLm1hcmt0eXBlLFxuICAgIGNvbDogX2NvbGVuYyxcbiAgICBlbmNvZGluZzogZW5jb2RpbmcuZW5jb2RpbmdcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdlbjoge30sXG4gIGNsdXN0ZXI6IHt9LFxuICByYW5rOiB7fVxufTtcblxuY29uc3RzLmdlbi5wcm9qZWN0aW9ucyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBvbWl0RG90UGxvdDogeyAvL0ZJWE1FIHJlbW92ZSB0aGlzIVxuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzJ1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JBdXRvQWRkT3JkaW5hbDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNTAsXG4gICAgICBkZXNjcmlwdGlvbjogJ21heCBjYXJkaW5hbGl0eSBmb3Igb3JkaW5hbCBmaWVsZCB0byBiZSBjb25zaWRlcmVkIGZvciBhdXRvIGFkZGluZydcbiAgICB9LFxuICAgIGFsd2F5c0FkZEhpc3RvZ3JhbToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuY29uc3RzLmdlbi5hZ2dyZWdhdGVzID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGNvbmZpZzoge1xuICAgICAgdHlwZTogJ29iamVjdCdcbiAgICB9LFxuICAgIGRhdGE6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfSxcbiAgICB0YWJsZVR5cGVzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiAnYm90aCcsXG4gICAgICBlbnVtOiBbJ2JvdGgnLCAnYWdncmVnYXRlZCcsICdkaXNhZ2dyZWdhdGVkJ11cbiAgICB9LFxuICAgIGdlbkRpbVE6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ2F1dG8nLFxuICAgICAgZW51bTogWydhdXRvJywgJ2JpbicsICdjYXN0JywgJ25vbmUnXSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVXNlIFEgYXMgRGltZW5zaW9uIGVpdGhlciBieSBiaW5uaW5nIG9yIGNhc3RpbmcnXG4gICAgfSxcbiAgICBtaW5DYXJkaW5hbGl0eUZvckJpbjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAsXG4gICAgICBkZXNjcmlwdGlvbjogJ21pbmltdW0gY2FyZGluYWxpdHkgb2YgYSBmaWVsZCBpZiB3ZSB3ZXJlIHRvIGJpbidcbiAgICB9LFxuICAgIG9taXREb3RQbG90OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVtb3ZlIGFsbCBkb3QgcGxvdHMnXG4gICAgfSxcbiAgICBvbWl0TWVhc3VyZU9ubHk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdPbWl0IGFnZ3JlZ2F0aW9uIHdpdGggbWVhc3VyZShzKSBvbmx5J1xuICAgIH0sXG4gICAgb21pdERpbWVuc2lvbk9ubHk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ09taXQgYWdncmVnYXRpb24gd2l0aCBkaW1lbnNpb24ocykgb25seSdcbiAgICB9LFxuICAgIGFkZENvdW50Rm9yRGltZW5zaW9uT25seToge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWRkIGNvdW50IHdoZW4gdGhlcmUgYXJlIGRpbWVuc2lvbihzKSBvbmx5J1xuICAgIH0sXG4gICAgYWdnckxpc3Q6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBbJ3N0cmluZyddXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogW3VuZGVmaW5lZCwgJ2F2ZyddXG4gICAgfSxcbiAgICB0aW1lRm5MaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogWydzdHJpbmcnXVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFsneWVhciddXG4gICAgfSxcbiAgICBjb25zaXN0ZW50QXV0b1E6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogXCJnZW5lcmF0ZSBzaW1pbGFyIGF1dG8gdHJhbnNmb3JtIGZvciBxdWFudFwiXG4gICAgfVxuICB9XG59O1xuXG5jb25zdHMuZ2VuLmVuY29kaW5ncyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXJrdHlwZUxpc3Q6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgIGRlZmF1bHQ6IFsncG9pbnQnLCAnYmFyJywgJ2xpbmUnLCAnYXJlYScsICd0ZXh0JywgJ3RpY2snXSwgLy9maWxsZWRfbWFwXG4gICAgICBkZXNjcmlwdGlvbjogJ2FsbG93ZWQgbWFya3R5cGVzJ1xuICAgIH0sXG4gICAgZW5jb2RpbmdUeXBlTGlzdDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgZGVmYXVsdDogWyd4JywgJ3knLCAncm93JywgJ2NvbCcsICdzaXplJywgJ2NvbG9yJywgJ3RleHQnLCAnZGV0YWlsJ10sXG4gICAgICBkZXNjcmlwdGlvbjogJ2FsbG93ZWQgZW5jb2RpbmcgdHlwZXMnXG4gICAgfSxcbiAgICBtYXhHb29kQ2FyZGluYWxpdHlGb3JGYWNldHM6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICBkZXNjcmlwdGlvbjogJ21heGltdW0gY2FyZGluYWxpdHkgb2YgYSBmaWVsZCB0byBiZSBwdXQgb24gZmFjZXQgKHJvdy9jb2wpIGVmZmVjdGl2ZWx5J1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JGYWNldHM6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgdG8gYmUgcHV0IG9uIGZhY2V0IChyb3cvY29sKSdcbiAgICB9LFxuICAgIG1heEdvb2RDYXJkaW5hbGl0eUZvckNvbG9yOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA3LFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGFuIG9yZGluYWwgZmllbGQgdG8gYmUgcHV0IG9uIGNvbG9yIGVmZmVjdGl2ZWx5J1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JDb2xvcjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAsXG4gICAgICBkZXNjcmlwdGlvbjogJ21heGltdW0gY2FyZGluYWxpdHkgb2YgYW4gb3JkaW5hbCBmaWVsZCB0byBiZSBwdXQgb24gY29sb3InXG4gICAgfSxcbiAgICBtYXhDYXJkaW5hbGl0eUZvclNoYXBlOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA2LFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGFuIG9yZGluYWwgZmllbGQgdG8gYmUgcHV0IG9uIHNoYXBlJ1xuICAgIH0sXG4gICAgb21pdFRyYW5wb3NlOiAge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRWxpbWluYXRlIGFsbCB0cmFuc3Bvc2UgYnkgKDEpIGtlZXBpbmcgaG9yaXpvbnRhbCBkb3QgcGxvdCBvbmx5ICgyKSBmb3IgT3hRIGNoYXJ0cywgYWx3YXlzIHB1dCBPIG9uIFkgKDMpIHNob3cgb25seSBvbmUgRHhELCBNeE0gKGN1cnJlbnRseSBzb3J0ZWQgYnkgbmFtZSknXG4gICAgfSxcbiAgICBvbWl0RG90UGxvdDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzJ1xuICAgIH0sXG4gICAgb21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZzoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVtb3ZlIGFsbCBkb3QgcGxvdHMgd2l0aCA+MSBlbmNvZGluZydcbiAgICB9LFxuICAgIG9taXRNdWx0aXBsZVJldGluYWxFbmNvZGluZ3M6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ29taXQgdXNpbmcgbXVsdGlwbGUgcmV0aW5hbCB2YXJpYWJsZXMgKHNpemUsIGNvbG9yLCBhbHBoYSwgc2hhcGUpJ1xuICAgIH0sXG4gICAgb21pdE5vblRleHRBZ2dyV2l0aEFsbERpbXNPbkZhY2V0czoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyAoZXhjZXB0IHRleHQgdGFibGVzKSB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpJ1xuICAgIH0sXG4gICAgb21pdFNpemVPbkJhcjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ2RvIG5vdCB1c2UgYmFyXFwncyBzaXplJ1xuICAgIH0sXG4gICAgb21pdFN0YWNrZWRBdmVyYWdlOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdkbyBub3Qgc3RhY2sgYmFyIGNoYXJ0IHdpdGggYXZlcmFnZSdcbiAgICB9LFxuICAgIGFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXA6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnZsIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC52bCA6IG51bGwpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyk7XG5cbnZhciBBTlk9JyonO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbkFnZ3JlZ2F0ZXM7XG5cbmZ1bmN0aW9uIGdlbkFnZ3JlZ2F0ZXMob3V0cHV0LCBmaWVsZHMsIHN0YXRzLCBvcHQpIHtcbiAgb3B0ID0gdmwuc2NoZW1hLnV0aWwuZXh0ZW5kKG9wdHx8e30sIGNvbnN0cy5nZW4uYWdncmVnYXRlcyk7XG4gIHZhciB0ZiA9IG5ldyBBcnJheShmaWVsZHMubGVuZ3RoKTtcbiAgdmFyIGhhc05vck8gPSB2bC5hbnkoZmllbGRzLCBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsLmZpZWxkLmlzVHlwZXMoZiwgW04sIE9dKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW1pdChmaWVsZFNldCkge1xuICAgIGZpZWxkU2V0ID0gdmwuZHVwbGljYXRlKGZpZWxkU2V0KTtcbiAgICBmaWVsZFNldC5rZXkgPSB2bC5maWVsZC5zaG9ydGhhbmRzKGZpZWxkU2V0KTtcbiAgICBvdXRwdXQucHVzaChmaWVsZFNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0FuZFB1c2goKSB7XG4gICAgaWYgKG9wdC5vbWl0TWVhc3VyZU9ubHkgfHwgb3B0Lm9taXREaW1lbnNpb25Pbmx5KSB7XG4gICAgICB2YXIgaGFzTWVhc3VyZSA9IGZhbHNlLCBoYXNEaW1lbnNpb24gPSBmYWxzZSwgaGFzUmF3ID0gZmFsc2U7XG4gICAgICB0Zi5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKHZsLmZpZWxkLmlzRGltZW5zaW9uKGYpKSB7XG4gICAgICAgICAgaGFzRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWYuYWdncmVnYXRlKSBoYXNSYXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzRGltZW5zaW9uICYmICFoYXNSYXcgJiYgb3B0Lm9taXRNZWFzdXJlT25seSkgcmV0dXJuO1xuICAgICAgaWYgKCFoYXNNZWFzdXJlKSB7XG4gICAgICAgIGlmIChvcHQuYWRkQ291bnRGb3JEaW1lbnNpb25Pbmx5KSB7XG4gICAgICAgICAgdGYucHVzaCh2bC5maWVsZC5jb3VudCgpKTtcbiAgICAgICAgICBlbWl0KHRmKTtcbiAgICAgICAgICB0Zi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0Lm9taXREaW1lbnNpb25Pbmx5KSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHQub21pdERvdFBsb3QgJiYgdGYubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgZW1pdCh0Zik7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgYSkge1xuICAgIHZhciBjYW5IYXZlQWdnciA9IGhhc0FnZ3IgPT09IHRydWUgfHwgaGFzQWdnciA9PT0gbnVsbCxcbiAgICAgIGNhbnRIYXZlQWdnciA9IGhhc0FnZ3IgPT09IGZhbHNlIHx8IGhhc0FnZ3IgPT09IG51bGw7XG4gICAgaWYgKGEpIHtcbiAgICAgIGlmIChjYW5IYXZlQWdncikge1xuICAgICAgICB0ZltpXS5hZ2dyZWdhdGUgPSBhO1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgdHJ1ZSwgYXV0b01vZGUpO1xuICAgICAgICBkZWxldGUgdGZbaV0uYWdncmVnYXRlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIGlmKGEgPT09IHVuZGVmaW5lZClcbiAgICAgIGlmIChjYW50SGF2ZUFnZ3IpIHtcbiAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGZhbHNlLCBhdXRvTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduQmluUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIHRmW2ldLmJpbiA9IHRydWU7XG4gICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICBkZWxldGUgdGZbaV0uYmluO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIHZhciBmID0gZmllbGRzW2ldLFxuICAgICAgY2FuSGF2ZUFnZ3IgPSBoYXNBZ2dyID09PSB0cnVlIHx8IGhhc0FnZ3IgPT09IG51bGw7XG5cbiAgICB0ZltpXSA9IHtuYW1lOiBmLm5hbWUsIHR5cGU6IGYudHlwZX07XG5cbiAgICBpZiAoZi5hZ2dyZWdhdGUgPT09ICdjb3VudCcpIHsgLy8gaWYgY291bnQgaXMgaW5jbHVkZWQgaW4gdGhlIHNlbGVjdGVkIGZpZWxkc1xuICAgICAgaWYgKGNhbkhhdmVBZ2dyKSB7XG4gICAgICAgIHRmW2ldLmFnZ3JlZ2F0ZSA9IGYuYWdncmVnYXRlO1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgdHJ1ZSwgYXV0b01vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZi5fYWdncmVnYXRlKSB7XG4gICAgICAvLyBUT0RPIHN1cHBvcnQgYXJyYXkgb2YgZi5fYWdncnMgdG9vXG4gICAgICBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgZi5fYWdncmVnYXRlKTtcbiAgICB9IGVsc2UgaWYgKGYuX3Jhdykge1xuICAgICAgYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYXV0b01vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChmLl9iaW4pIHtcbiAgICAgIGFzc2lnbkJpblEoaSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHQuYWdnckxpc3QuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmICghb3B0LmNvbnNpc3RlbnRBdXRvUSB8fCBhdXRvTW9kZSA9PT0gQU5ZIHx8IGF1dG9Nb2RlID09PSBhKSB7XG4gICAgICAgICAgYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYSAvKmFzc2lnbiBhdXRvTW9kZSovLCBhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgoIW9wdC5jb25zaXN0ZW50QXV0b1EgfHwgdmwuaXNpbihhdXRvTW9kZSwgW0FOWSwgJ2JpbicsICdjYXN0JywgJ2F1dG9jYXN0J10pKSAmJiAhaGFzTm9yTykge1xuICAgICAgICB2YXIgaGlnaENhcmRpbmFsaXR5ID0gdmwuZmllbGQuY2FyZGluYWxpdHkoZiwgc3RhdHMpID4gb3B0Lm1pbkNhcmRpbmFsaXR5Rm9yQmluO1xuXG4gICAgICAgIHZhciBpc0F1dG8gPSBvcHQuZ2VuRGltUSA9PT0gJ2F1dG8nLFxuICAgICAgICAgIGdlbkJpbiA9IG9wdC5nZW5EaW1RICA9PT0gJ2JpbicgfHwgKGlzQXV0byAmJiBoaWdoQ2FyZGluYWxpdHkpLFxuICAgICAgICAgIGdlbkNhc3QgPSBvcHQuZ2VuRGltUSA9PT0gJ2Nhc3QnIHx8IChpc0F1dG8gJiYgIWhpZ2hDYXJkaW5hbGl0eSk7XG5cbiAgICAgICAgaWYgKGdlbkJpbiAmJiB2bC5pc2luKGF1dG9Nb2RlLCBbQU5ZLCAnYmluJywgJ2F1dG9jYXN0J10pKSB7XG4gICAgICAgICAgYXNzaWduQmluUShpLCBoYXNBZ2dyLCBpc0F1dG8gPyAnYXV0b2Nhc3QnIDogJ2JpbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5DYXN0ICYmIHZsLmlzaW4oYXV0b01vZGUsIFtBTlksICdjYXN0JywgJ2F1dG9jYXN0J10pKSB7XG4gICAgICAgICAgdGZbaV0udHlwZSA9ICdPJztcbiAgICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgaGFzQWdnciwgaXNBdXRvID8gJ2F1dG9jYXN0JyA6ICdjYXN0Jyk7XG4gICAgICAgICAgdGZbaV0udHlwZSA9ICdRJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbkZuVChpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgZm4pIHtcbiAgICB0ZltpXS5mbiA9IGZuO1xuICAgIGFzc2lnbkZpZWxkKGkrMSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgIGRlbGV0ZSB0ZltpXS5mbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblQoaSwgaGFzQWdnciwgYXV0b01vZGUpIHtcbiAgICB2YXIgZiA9IGZpZWxkc1tpXTtcbiAgICB0ZltpXSA9IHtuYW1lOiBmLm5hbWUsIHR5cGU6IGYudHlwZX07XG5cbiAgICAvLyBUT0RPIHN1cHBvcnQgYXJyYXkgb2YgZi5fZm5zXG4gICAgaWYgKGYuX2ZuKSB7XG4gICAgICBhc3NpZ25GblQoaSwgaGFzQWdnciwgYXV0b01vZGUsIGYuX2ZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0LnRpbWVGbkxpc3QuZm9yRWFjaChmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghaGFzQWdncikgeyAvLyBjYW4ndCBhZ2dyZWdhdGUgb3ZlciByYXcgdGltZVxuICAgICAgICAgICAgYXNzaWduRmllbGQoaSsxLCBmYWxzZSwgYXV0b01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25GblQoaSwgaGFzQWdnciwgYXV0b01vZGUsIGZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRklYTUUgd2hhdCBpZiB5b3UgYWdncmVnYXRlIHRpbWU/XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25GaWVsZChpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIGlmIChpID09PSBmaWVsZHMubGVuZ3RoKSB7IC8vIElmIGFsbCBmaWVsZHMgYXJlIGFzc2lnbmVkXG4gICAgICBjaGVja0FuZFB1c2goKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZiA9IGZpZWxkc1tpXTtcbiAgICAvLyBPdGhlcndpc2UsIGFzc2lnbiBpLXRoIGZpZWxkXG4gICAgc3dpdGNoIChmLnR5cGUpIHtcbiAgICAgIC8vVE9ETyBcIkRcIiwgXCJHXCJcbiAgICAgIGNhc2UgUTpcbiAgICAgICAgYXNzaWduUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFQ6XG4gICAgICAgIGFzc2lnblQoaSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0ZltpXSA9IGY7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXNBZ2dyID0gb3B0LnRhYmxlVHlwZXMgPT09ICdhZ2dyZWdhdGVkJyA/IHRydWUgOiBvcHQudGFibGVUeXBlcyA9PT0gJ2Rpc2FnZ3JlZ2F0ZWQnID8gZmFsc2UgOiBudWxsO1xuICBhc3NpZ25GaWVsZCgwLCBoYXNBZ2dyLCBBTlkpO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnZsIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC52bCA6IG51bGwpLFxuICBnZW5FbmNzID0gcmVxdWlyZSgnLi9lbmNzJyksXG4gIGdldE1hcmt0eXBlcyA9IHJlcXVpcmUoJy4vbWFya3R5cGVzJyksXG4gIHJhbmsgPSByZXF1aXJlKCcuLi9yYW5rL3JhbmsnKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuRW5jb2RpbmdzRnJvbUZpZWxkcztcblxuZnVuY3Rpb24gZ2VuRW5jb2RpbmdzRnJvbUZpZWxkcyhvdXRwdXQsIGZpZWxkcywgc3RhdHMsIG9wdCwgbmVzdGVkKSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmVuY29kaW5ncyk7XG4gIHZhciBlbmNzID0gZ2VuRW5jcyhbXSwgZmllbGRzLCBzdGF0cywgb3B0KTtcblxuICBpZiAobmVzdGVkKSB7XG4gICAgcmV0dXJuIGVuY3MucmVkdWNlKGZ1bmN0aW9uKGRpY3QsIGVuYykge1xuICAgICAgZGljdFtlbmNdID0gZ2VuRW5jb2RpbmdzRnJvbUVuY3MoW10sIGVuYywgc3RhdHMsIG9wdCk7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuY3MucmVkdWNlKGZ1bmN0aW9uKGxpc3QsIGVuYykge1xuICAgICAgcmV0dXJuIGdlbkVuY29kaW5nc0Zyb21FbmNzKGxpc3QsIGVuYywgc3RhdHMsIG9wdCk7XG4gICAgfSwgW10pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVuY29kaW5nc0Zyb21FbmNzKG91dHB1dCwgZW5jLCBzdGF0cywgb3B0KSB7XG4gIGdldE1hcmt0eXBlcyhlbmMsIHN0YXRzLCBvcHQpXG4gICAgLmZvckVhY2goZnVuY3Rpb24obWFya1R5cGUpIHtcbiAgICAgIHZhciBlID0gdmwuZHVwbGljYXRlKHtcbiAgICAgICAgICBkYXRhOiBvcHQuZGF0YSxcbiAgICAgICAgICBtYXJrdHlwZTogbWFya1R5cGUsXG4gICAgICAgICAgZW5jb2Rpbmc6IGVuYyxcbiAgICAgICAgICBjb25maWc6IG9wdC5jb25maWdcbiAgICAgICAgfSksXG4gICAgICAgIGVuY29kaW5nID0gZmluYWxUb3VjaChlLCBzdGF0cywgb3B0KSxcbiAgICAgICAgc2NvcmUgPSByYW5rLmVuY29kaW5nKGVuY29kaW5nLCBzdGF0cywgb3B0KTtcblxuICAgICAgZW5jb2Rpbmcuc2NvcmUgPSBzY29yZS5zY29yZTtcbiAgICAgIGVuY29kaW5nLnNjb3JlRmVhdHVyZXMgPSBzY29yZS5mZWF0dXJlcztcbiAgICAgIG91dHB1dC5wdXNoKGVuY29kaW5nKTtcbiAgICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy9GSVhNRSB0aGlzIHNob3VsZCBiZSByZWZhY3RvcnNcbmZ1bmN0aW9uIGZpbmFsVG91Y2goZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlID09PSAndGV4dCcgJiYgb3B0LmFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXApIHtcbiAgICBlbmNvZGluZy5lbmNvZGluZy5jb2xvciA9IGVuY29kaW5nLmVuY29kaW5nLnRleHQ7XG4gIH1cblxuICAvLyBkb24ndCBpbmNsdWRlIHplcm8gaWYgc3RkZXYvYXZnIDwgMC4wMVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdXdkYXRhL3Zpc3JlYy9pc3N1ZXMvNjlcbiAgdmFyIGVuYyA9IGVuY29kaW5nLmVuY29kaW5nO1xuICBbJ3gnLCAneSddLmZvckVhY2goZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgZmllbGQgPSBlbmNbZXRdO1xuICAgIGlmIChmaWVsZCAmJiB2bC5maWVsZC5pc01lYXN1cmUoZmllbGQpICYmICF2bC5maWVsZC5pc0NvdW50KGZpZWxkKSkge1xuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXTtcbiAgICAgIGlmIChzdGF0ICYmIHN0YXQuc3RkZXYgLyBzdGF0LmF2ZyA8IDAuMDEpIHtcbiAgICAgICAgZmllbGQuc2NhbGUgPSB7emVybzogZmFsc2V9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGluZztcbn0iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4uL2NvbnN0cycpLFxuICBnZW5NYXJrVHlwZXMgPSByZXF1aXJlKCcuL21hcmt0eXBlcycpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmZpZWxkLmlzRGltZW5zaW9uLFxuICBpc01lYXN1cmUgPSB2bC5maWVsZC5pc01lYXN1cmU7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuRW5jcztcblxuLy8gRklYTUUgcmVtb3ZlIGRpbWVuc2lvbiwgbWVhc3VyZSBhbmQgdXNlIGluZm9ybWF0aW9uIGluIHZlZ2EtbGl0ZSBpbnN0ZWFkIVxudmFyIHJ1bGVzID0ge1xuICB4OiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWUgLy9GSVhNRSBzaG91bGQgYWxsb3cgbXVsdGlwbGUgb25seSBmb3IgUSwgVFxuICB9LFxuICB5OiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWUgLy9GSVhNRSBzaG91bGQgYWxsb3cgbXVsdGlwbGUgb25seSBmb3IgUSwgVFxuICB9LFxuICByb3c6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWVcbiAgfSxcbiAgY29sOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIG11bHRpcGxlOiB0cnVlXG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlLFxuICAgIHJ1bGVzOiBzaGFwZVJ1bGVzXG4gIH0sXG4gIHNpemU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIHJ1bGVzOiByZXRpbmFsRW5jUnVsZXNcbiAgfSxcbiAgY29sb3I6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBydWxlczogY29sb3JSdWxlc1xuICB9LFxuICBhbHBoYToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgcnVsZXM6IHJldGluYWxFbmNSdWxlc1xuICB9LFxuICB0ZXh0OiB7XG4gICAgbWVhc3VyZTogdHJ1ZVxuICB9LFxuICBkZXRhaWw6IHtcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfVxuICAvL2dlbzoge1xuICAvLyAgZ2VvOiB0cnVlXG4gIC8vfSxcbiAgLy9hcmM6IHsgLy8gcGllXG4gIC8vXG4gIC8vfVxufTtcblxuZnVuY3Rpb24gcmV0aW5hbEVuY1J1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpIHtcbiAgaWYgKG9wdC5vbWl0TXVsdGlwbGVSZXRpbmFsRW5jb2RpbmdzKSB7XG4gICAgaWYgKGVuYy5jb2xvciB8fCBlbmMuc2l6ZSB8fCBlbmMuc2hhcGUgfHwgZW5jLmFscGhhKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbG9yUnVsZXMoZW5jLCBmaWVsZCwgc3RhdHMsIG9wdCkge1xuICBpZighcmV0aW5hbEVuY1J1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHZsLmZpZWxkLmlzTWVhc3VyZShmaWVsZCkgfHxcbiAgICB2bC5maWVsZC5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMpIDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckNvbG9yO1xufVxuXG5mdW5jdGlvbiBzaGFwZVJ1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIXJldGluYWxFbmNSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmaWVsZC5iaW4gJiYgZmllbGQudHlwZSA9PT0gUSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmllbGQuZm4gJiYgZmllbGQudHlwZSA9PT0gVCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvcjtcbn1cblxuZnVuY3Rpb24gZGltTWVhVHJhbnNwb3NlUnVsZShlbmMpIHtcbiAgLy8gY3JlYXRlIGhvcml6b250YWwgaGlzdG9ncmFtIGZvciBvcmRpbmFsXG4gIGlmICh2bC5maWVsZC5pc1R5cGVzKGVuYy55LCBbTiwgT10pICYmIGlzTWVhc3VyZShlbmMueCkpIHJldHVybiB0cnVlO1xuXG4gIC8vIHZlcnRpY2FsIGhpc3RvZ3JhbSBmb3IgUSBhbmQgVFxuICBpZiAoaXNNZWFzdXJlKGVuYy55KSAmJiAoIXZsLmZpZWxkLmlzVHlwZXMoZW5jLngsIFtOLCBPXSkgJiYgaXNEaW1lbnNpb24oZW5jLngpKSkgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZW5lcmFsUnVsZXMoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGVuYy50ZXh0IGlzIG9ubHkgdXNlZCBmb3IgVEVYVCBUQUJMRVxuICBpZiAoZW5jLnRleHQpIHtcbiAgICByZXR1cm4gZ2VuTWFya1R5cGVzLnNhdGlzZnlSdWxlcyhlbmMsIFRFWFQsIHN0YXRzLCBvcHQpO1xuICB9XG5cbiAgLy8gQ0FSVEVTSUFOIFBMT1QgT1IgTUFQXG4gIGlmIChlbmMueCB8fCBlbmMueSB8fCBlbmMuZ2VvIHx8IGVuYy5hcmMpIHtcblxuICAgIGlmIChlbmMucm93IHx8IGVuYy5jb2wpIHsgLy9oYXZlIGZhY2V0KHMpXG5cbiAgICAgIC8vIGRvbid0IHVzZSBmYWNldHMgYmVmb3JlIGZpbGxpbmcgdXAgeCx5XG4gICAgICBpZiAoIWVuYy54IHx8ICFlbmMueSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAob3B0Lm9taXROb25UZXh0QWdncldpdGhBbGxEaW1zT25GYWNldHMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpXG4gICAgICAgIGlmIChnZW5FbmNzLmlzQWdncldpdGhBbGxEaW1PbkZhY2V0cyhlbmMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuYy54ICYmIGVuYy55KSB7XG4gICAgICB2YXIgaXNEaW1YID0gISFpc0RpbWVuc2lvbihlbmMueCksXG4gICAgICAgIGlzRGltWSA9ICEhaXNEaW1lbnNpb24oZW5jLnkpO1xuXG4gICAgICBpZiAoaXNEaW1YICYmIGlzRGltWSAmJiAhdmwuZW5jLmlzQWdncmVnYXRlKGVuYykpIHtcbiAgICAgICAgLy8gRklYTUUgYWN0dWFsbHkgY2hlY2sgaWYgdGhlcmUgd291bGQgYmUgb2NjbHVzaW9uICM5MFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQub21pdFRyYW5wb3NlKSB7XG4gICAgICAgIGlmIChpc0RpbVggXiBpc0RpbVkpIHsgLy8gZGltIHggbWVhXG4gICAgICAgICAgaWYgKCFkaW1NZWFUcmFuc3Bvc2VSdWxlKGVuYykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbmMueS50eXBlPT09VCB8fCBlbmMueC50eXBlID09PSBUKSB7XG4gICAgICAgICAgaWYgKGVuYy55LnR5cGU9PT1UICYmIGVuYy54LnR5cGUgIT09IFQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyBvbmx5IG9uZSBPeE8sIFF4UVxuICAgICAgICAgIGlmIChlbmMueC5uYW1lID4gZW5jLnkubmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBET1QgUExPVFNcbiAgICAvLyAvLyBwbG90IHdpdGggb25lIGF4aXMgPSBkb3QgcGxvdFxuICAgIGlmIChvcHQub21pdERvdFBsb3QpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIERvdCBwbG90IHNob3VsZCBhbHdheXMgYmUgaG9yaXpvbnRhbFxuICAgIGlmIChvcHQub21pdFRyYW5wb3NlICYmIGVuYy55KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCBzaG91bGRuJ3QgaGF2ZSBvdGhlciBlbmNvZGluZ1xuICAgIGlmIChvcHQub21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZyAmJiB2bC5rZXlzKGVuYykubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gb25lIGRpbWVuc2lvbiBcImNvdW50XCIgaXMgdXNlbGVzc1xuICAgIGlmIChlbmMueCAmJiBlbmMueC5hZ2dyZWdhdGUgPT0gJ2NvdW50JyAmJiAhZW5jLnkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZW5jLnkgJiYgZW5jLnkuYWdncmVnYXRlID09ICdjb3VudCcgJiYgIWVuYy54KSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmdlbkVuY3MuaXNBZ2dyV2l0aEFsbERpbU9uRmFjZXRzID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaGFzQWdnciA9IGZhbHNlLCBoYXNPdGhlck8gPSBmYWxzZTtcbiAgZm9yICh2YXIgZW5jVHlwZSBpbiBlbmMpIHtcbiAgICB2YXIgZmllbGQgPSBlbmNbZW5jVHlwZV07XG4gICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgICAgaGFzQWdnciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2bC5maWVsZC5pc0RpbWVuc2lvbihmaWVsZCkgJiYgKGVuY1R5cGUgIT09IFJPVyAmJiBlbmNUeXBlICE9PSBDT0wpKSB7XG4gICAgICBoYXNPdGhlck8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzQWdnciAmJiBoYXNPdGhlck8pIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGhhc0FnZ3IgJiYgIWhhc090aGVyTztcbn07XG5cblxuZnVuY3Rpb24gZ2VuRW5jcyhlbmNzLCBmaWVsZHMsIHN0YXRzLCBvcHQpIHtcbiAgb3B0ID0gdmwuc2NoZW1hLnV0aWwuZXh0ZW5kKG9wdHx8e30sIGNvbnN0cy5nZW4uZW5jb2RpbmdzKTtcbiAgLy8gZ2VuZXJhdGUgYSBjb2xsZWN0aW9uIHZlZ2EtbGl0ZSdzIGVuY1xuICB2YXIgdG1wRW5jID0ge307XG5cbiAgZnVuY3Rpb24gYXNzaWduRmllbGQoaSkge1xuICAgIC8vIElmIGFsbCBmaWVsZHMgYXJlIGFzc2lnbmVkLCBzYXZlXG4gICAgaWYgKGkgPT09IGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgIC8vIGF0IHRoZSBtaW5pbWFsIGFsbCBjaGFydCBzaG91bGQgaGF2ZSB4LCB5LCBnZW8sIHRleHQgb3IgYXJjXG4gICAgICBpZiAoZ2VuZXJhbFJ1bGVzKHRtcEVuYywgc3RhdHMsIG9wdCkpIHtcbiAgICAgICAgZW5jcy5wdXNoKHZsLmR1cGxpY2F0ZSh0bXBFbmMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGFzc2lnbiBpLXRoIGZpZWxkXG4gICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgIGZvciAodmFyIGogaW4gb3B0LmVuY29kaW5nVHlwZUxpc3QpIHtcbiAgICAgIHZhciBldCA9IG9wdC5lbmNvZGluZ1R5cGVMaXN0W2pdLFxuICAgICAgICBpc0RpbSA9IGlzRGltZW5zaW9uKGZpZWxkKTtcblxuICAgICAgLy9UT0RPOiBzdXBwb3J0IFwibXVsdGlwbGVcIiBhc3NpZ25tZW50XG4gICAgICBpZiAoIShldCBpbiB0bXBFbmMpICYmIC8vIGVuY29kaW5nIG5vdCB1c2VkXG4gICAgICAgICgoaXNEaW0gJiYgcnVsZXNbZXRdLmRpbWVuc2lvbikgfHwgKCFpc0RpbSAmJiBydWxlc1tldF0ubWVhc3VyZSkpICYmXG4gICAgICAgICghcnVsZXNbZXRdLnJ1bGVzIHx8IHJ1bGVzW2V0XS5ydWxlcyh0bXBFbmMsIGZpZWxkLCBzdGF0cywgb3B0KSlcbiAgICAgICkge1xuICAgICAgICB0bXBFbmNbZXRdID0gZmllbGQ7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxKTtcbiAgICAgICAgZGVsZXRlIHRtcEVuY1tldF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXNzaWduRmllbGQoMCk7XG5cbiAgcmV0dXJuIGVuY3M7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgZ2VuID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGRhdGEgdmFyaWF0aW9uc1xuICBhZ2dyZWdhdGVzOiByZXF1aXJlKCcuL2FnZ3JlZ2F0ZXMnKSxcbiAgcHJvamVjdGlvbnM6IHJlcXVpcmUoJy4vcHJvamVjdGlvbnMnKSxcbiAgLy8gZW5jb2RpbmdzIC8gdmlzdWFsIHZhcmlhdG9uc1xuICBlbmNvZGluZ3M6IHJlcXVpcmUoJy4vZW5jb2RpbmdzJyksXG4gIGVuY3M6IHJlcXVpcmUoJy4vZW5jcycpLFxuICBtYXJrdHlwZXM6IHJlcXVpcmUoJy4vbWFya3R5cGVzJylcbn07XG5cbmdlbi5jaGFydHMgPSBmdW5jdGlvbihmaWVsZHMsIG9wdCwgY2ZnLCBmbGF0KSB7XG4gIG9wdCA9IHV0aWwuZ2VuLmdldE9wdChvcHQpO1xuICBmbGF0ID0gZmxhdCA9PT0gdW5kZWZpbmVkID8ge2VuY29kaW5nczogMX0gOiBmbGF0O1xuXG4gIC8vIFRPRE8gZ2VuZXJhdGVcblxuICAvLyBnZW5lcmF0ZSBwZXJtdXRhdGlvbiBvZiBlbmNvZGluZyBtYXBwaW5nc1xuICB2YXIgZmllbGRTZXRzID0gb3B0LmdlbkFnZ3IgPyBnZW4uYWdncmVnYXRlcyhbXSwgZmllbGRzLCBvcHQpIDogW2ZpZWxkc10sXG4gICAgZW5jcywgY2hhcnRzLCBsZXZlbCA9IDA7XG5cbiAgaWYgKGZsYXQgPT09IHRydWUgfHwgKGZsYXQgJiYgZmxhdC5hZ2dyZWdhdGUpKSB7XG4gICAgZW5jcyA9IGZpZWxkU2V0cy5yZWR1Y2UoZnVuY3Rpb24ob3V0cHV0LCBmaWVsZHMpIHtcbiAgICAgIHJldHVybiBnZW4uZW5jcyhvdXRwdXQsIGZpZWxkcywgb3B0KTtcbiAgICB9LCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgZW5jcyA9IGZpZWxkU2V0cy5tYXAoZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICByZXR1cm4gZ2VuLmVuY3MoW10sIGZpZWxkcywgb3B0KTtcbiAgICB9LCB0cnVlKTtcbiAgICBsZXZlbCArPSAxO1xuICB9XG5cbiAgaWYgKGZsYXQgPT09IHRydWUgfHwgKGZsYXQgJiYgZmxhdC5lbmNvZGluZ3MpKSB7XG4gICAgY2hhcnRzID0gdXRpbC5uZXN0ZWRSZWR1Y2UoZW5jcywgZnVuY3Rpb24ob3V0cHV0LCBlbmMpIHtcbiAgICAgIHJldHVybiBnZW4ubWFya3R5cGVzKG91dHB1dCwgZW5jLCBvcHQsIGNmZyk7XG4gICAgfSwgbGV2ZWwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJ0cyA9IHV0aWwubmVzdGVkTWFwKGVuY3MsIGZ1bmN0aW9uKGVuYykge1xuICAgICAgcmV0dXJuIGdlbi5tYXJrdHlwZXMoW10sIGVuYywgb3B0LCBjZmcpO1xuICAgIH0sIGxldmVsLCB0cnVlKTtcbiAgICBsZXZlbCArPSAxO1xuICB9XG4gIHJldHVybiBjaGFydHM7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyksXG4gIGlzRGltZW5zaW9uID0gdmwuZmllbGQuaXNEaW1lbnNpb24sXG4gIGlzT3JkaW5hbFNjYWxlID0gdmwuZmllbGQuaXNPcmRpbmFsU2NhbGU7XG5cbnZhciB2bG1hcmt0eXBlcyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3R5cGVzO1xuXG52YXIgbWFya3NSdWxlID0gdmxtYXJrdHlwZXMucnVsZSA9IHtcbiAgcG9pbnQ6ICBwb2ludFJ1bGUsXG4gIGJhcjogICAgYmFyUnVsZSxcbiAgbGluZTogICBsaW5lUnVsZSxcbiAgYXJlYTogICBhcmVhUnVsZSwgLy8gYXJlYSBpcyBzaW1pbGFyIHRvIGxpbmVcbiAgdGV4dDogICB0ZXh0UnVsZSxcbiAgdGljazogICB0aWNrUnVsZVxufTtcblxuZnVuY3Rpb24gZ2V0TWFya3R5cGVzKGVuYywgc3RhdHMsIG9wdCkge1xuICBvcHQgPSB2bC5zY2hlbWEudXRpbC5leHRlbmQob3B0fHx7fSwgY29uc3RzLmdlbi5lbmNvZGluZ3MpO1xuXG4gIHZhciBtYXJrVHlwZXMgPSBvcHQubWFya3R5cGVMaXN0LmZpbHRlcihmdW5jdGlvbihtYXJrVHlwZSl7XG4gICAgcmV0dXJuIHZsbWFya3R5cGVzLnNhdGlzZnlSdWxlcyhlbmMsIG1hcmtUeXBlLCBzdGF0cywgb3B0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcmtUeXBlcztcbn1cblxudmxtYXJrdHlwZXMuc2F0aXNmeVJ1bGVzID0gZnVuY3Rpb24gKGVuYywgbWFya1R5cGUsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIG1hcmsgPSB2bC5jb21waWxlLm1hcmtzW21hcmtUeXBlXSxcbiAgICByZXFzID0gbWFyay5yZXF1aXJlZEVuY29kaW5nLFxuICAgIHN1cHBvcnQgPSBtYXJrLnN1cHBvcnRlZEVuY29kaW5nO1xuXG4gIGZvciAodmFyIGkgaW4gcmVxcykgeyAvLyBhbGwgcmVxdWlyZWQgZW5jb2RpbmdzIGluIGVuY1xuICAgIGlmICghKHJlcXNbaV0gaW4gZW5jKSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgZW5jVHlwZSBpbiBlbmMpIHsgLy8gYWxsIGVuY29kaW5ncyBpbiBlbmMgYXJlIHN1cHBvcnRlZFxuICAgIGlmICghc3VwcG9ydFtlbmNUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICFtYXJrc1J1bGVbbWFya1R5cGVdIHx8IG1hcmtzUnVsZVttYXJrVHlwZV0oZW5jLCBzdGF0cywgb3B0KTtcbn07XG5cbmZ1bmN0aW9uIGZhY2V0UnVsZShmaWVsZCwgc3RhdHMsIG9wdCkge1xuICByZXR1cm4gdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JGYWNldHM7XG59XG5cbmZ1bmN0aW9uIGZhY2V0c1J1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIGlmKGVuYy5yb3cgJiYgIWZhY2V0UnVsZShlbmMucm93LCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICBpZihlbmMuY29sICYmICFmYWNldFJ1bGUoZW5jLmNvbCwgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBvaW50UnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIWZhY2V0c1J1bGUoZW5jLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZW5jLnggJiYgZW5jLnkpIHtcbiAgICAvLyBoYXZlIGJvdGggeCAmIHkgPT0+IHNjYXR0ZXIgcGxvdCAvIGJ1YmJsZSBwbG90XG5cbiAgICB2YXIgeElzRGltID0gaXNEaW1lbnNpb24oZW5jLngpLFxuICAgICAgeUlzRGltID0gaXNEaW1lbnNpb24oZW5jLnkpO1xuXG4gICAgLy8gRm9yIE94T1xuICAgIGlmICh4SXNEaW0gJiYgeUlzRGltKSB7XG4gICAgICAvLyBzaGFwZSBkb2Vzbid0IHdvcmsgd2l0aCBib3RoIHgsIHkgYXMgb3JkaW5hbFxuICAgICAgaWYgKGVuYy5zaGFwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8oa2FuaXR3KTogY2hlY2sgdGhhdCB0aGVyZSBpcyBxdWFudCBhdCBsZWFzdCAuLi5cbiAgICAgIGlmIChlbmMuY29sb3IgJiYgaXNEaW1lbnNpb24oZW5jLmNvbG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7IC8vIHBsb3Qgd2l0aCBvbmUgYXhpcyA9IGRvdCBwbG90XG4gICAgaWYgKG9wdC5vbWl0RG90UGxvdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gRG90IHBsb3Qgc2hvdWxkIGFsd2F5cyBiZSBob3Jpem9udGFsXG4gICAgaWYgKG9wdC5vbWl0VHJhbnBvc2UgJiYgZW5jLnkpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGRvdCBwbG90IHNob3VsZG4ndCBoYXZlIG90aGVyIGVuY29kaW5nXG4gICAgaWYgKG9wdC5vbWl0RG90UGxvdFdpdGhFeHRyYUVuY29kaW5nICYmIHZsLmtleXMoZW5jKS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCB3aXRoIHNoYXBlIGlzIG5vbi1zZW5zZVxuICAgIGlmIChlbmMuc2hhcGUpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdGlja1J1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgaWYgKGVuYy54IHx8IGVuYy55KSB7XG4gICAgaWYodmwuZW5jLmlzQWdncmVnYXRlKGVuYykpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB4SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueCksXG4gICAgICB5SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueSk7XG5cbiAgICByZXR1cm4gKCF4SXNEaW0gJiYgKCFlbmMueSB8fCBpc09yZGluYWxTY2FsZShlbmMueSkpKSB8fFxuICAgICAgKCF5SXNEaW0gJiYgKCFlbmMueCB8fCBpc09yZGluYWxTY2FsZShlbmMueCkpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGJhclJ1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICAvLyBuZWVkIHRvIGFnZ3JlZ2F0ZSBvbiBlaXRoZXIgeCBvciB5XG4gIGlmIChvcHQub21pdFNpemVPbkJhciAmJiBlbmMuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gRklYTUUgYWN0dWFsbHkgY2hlY2sgaWYgdGhlcmUgd291bGQgYmUgb2NjbHVzaW9uICM5MFxuICBpZiAoKChlbmMueC5hZ2dyZWdhdGUgIT09IHVuZGVmaW5lZCkgXiAoZW5jLnkuYWdncmVnYXRlICE9PSB1bmRlZmluZWQpKSAmJlxuICAgICAgKGlzRGltZW5zaW9uKGVuYy54KSBeIGlzRGltZW5zaW9uKGVuYy55KSkpIHtcblxuICAgIHZhciBhZ2dyZWdhdGUgPSBlbmMueC5hZ2dyZWdhdGUgfHwgZW5jLnkuYWdncmVnYXRlO1xuICAgIHJldHVybiAhKG9wdC5vbWl0U3RhY2tlZEF2ZXJhZ2UgJiYgYWdncmVnYXRlID09PSdhdmcnICYmIGVuYy5jb2xvcik7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETyhrYW5pdHcpOiBhZGQgb21pdFZlcnRpY2FsTGluZSBhcyBjb25maWdcblxuICAvLyBGSVhNRSB0cnVseSBvcmRpbmFsIGRhdGEgaXMgZmluZSBoZXJlIHRvby5cbiAgLy8gTGluZSBjaGFydCBzaG91bGQgYmUgb25seSBob3Jpem9udGFsXG4gIC8vIGFuZCB1c2Ugb25seSB0ZW1wb3JhbCBkYXRhXG4gIHJldHVybiBlbmMueC50eXBlID09ICdUJyAmJiBlbmMueC5mbiAmJiBlbmMueS50eXBlID09ICdRJyAmJiBlbmMueS5hZ2dyZWdhdGU7XG59XG5cbmZ1bmN0aW9uIGFyZWFSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYoIWxpbmVSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGVuYy55LmFnZ3JlZ2F0ZSA9PT0nYXZnJyAmJiBlbmMuY29sb3IpO1xufVxuXG5mdW5jdGlvbiB0ZXh0UnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgLy8gYXQgbGVhc3QgbXVzdCBoYXZlIHJvdyBvciBjb2wgYW5kIGFnZ3JlZ2F0ZWQgdGV4dCB2YWx1ZXNcbiAgcmV0dXJuIChlbmMucm93IHx8IGVuYy5jb2wpICYmIGVuYy50ZXh0ICYmIGVuYy50ZXh0LmFnZ3JlZ2F0ZSAmJiAhZW5jLnggJiYgIWVuYy55ICYmICFlbmMuc2l6ZSAmJlxuICAgICghb3B0LmFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXAgfHwgIWVuYy5jb2xvcik7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyksXG4gIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudmwgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnZsIDogbnVsbCksXG4gIGlzRGltZW5zaW9uID0gdmwuZmllbGQuaXNEaW1lbnNpb247XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvamVjdGlvbnM7XG5cbi8vIFRPRE8gc3VwcG9ydCBvdGhlciBtb2RlIG9mIHByb2plY3Rpb25zIGdlbmVyYXRpb25cbi8vIHBvd2Vyc2V0LCBjaG9vc2VLLCBjaG9vc2VLb3JMZXNzIGFyZSBhbHJlYWR5IGluY2x1ZGVkIGluIHRoZSB1dGlsXG5cbi8qKlxuICogZmllbGRzXG4gKiBAcGFyYW0gIHtbdHlwZV19IGZpZWxkcyBhcnJheSBvZiBmaWVsZHMgYW5kIHF1ZXJ5IGluZm9ybWF0aW9uXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIHByb2plY3Rpb25zKGZpZWxkcywgc3RhdHMsIG9wdCkge1xuICBvcHQgPSB2bC5zY2hlbWEudXRpbC5leHRlbmQob3B0fHx7fSwgY29uc3RzLmdlbi5wcm9qZWN0aW9ucyk7XG5cbiAgLy8gRmlyc3QgY2F0ZWdvcml6ZSBmaWVsZCwgc2VsZWN0ZWQsIGZpZWxkc1RvQWRkLCBhbmQgc2F2ZSBpbmRpY2VzXG4gIHZhciBzZWxlY3RlZCA9IFtdLCBmaWVsZHNUb0FkZCA9IFtdLCBmaWVsZFNldHMgPSBbXSxcbiAgICBoYXNTZWxlY3RlZERpbWVuc2lvbiA9IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkTWVhc3VyZSA9IGZhbHNlLFxuICAgIGluZGljZXMgPSB7fTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgaW5kZXgpe1xuICAgIC8vc2F2ZSBpbmRpY2VzIGZvciBzdGFibGUgc29ydCBsYXRlclxuICAgIGluZGljZXNbZmllbGQubmFtZV0gPSBpbmRleDtcblxuICAgIGlmIChmaWVsZC5zZWxlY3RlZCkge1xuICAgICAgc2VsZWN0ZWQucHVzaChmaWVsZCk7XG4gICAgICBpZiAoaXNEaW1lbnNpb24oZmllbGQpIHx8IGZpZWxkLnR5cGUgPT09J1QnKSB7IC8vIEZJWE1FIC8gSEFDS1xuICAgICAgICBoYXNTZWxlY3RlZERpbWVuc2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNTZWxlY3RlZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmllbGQuc2VsZWN0ZWQgIT09IGZhbHNlICYmICF2bC5maWVsZC5pc0NvdW50KGZpZWxkKSkge1xuICAgICAgaWYgKHZsLmZpZWxkLmlzRGltZW5zaW9uKGZpZWxkKSAmJlxuICAgICAgICAgICFvcHQubWF4Q2FyZGluYWxpdHlGb3JBdXRvQWRkT3JkaW5hbCAmJlxuICAgICAgICAgIHZsLmZpZWxkLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgMTUpID4gb3B0Lm1heENhcmRpbmFsaXR5Rm9yQXV0b0FkZE9yZGluYWxcbiAgICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZpZWxkc1RvQWRkLnB1c2goZmllbGQpO1xuICAgIH1cbiAgfSk7XG5cbiAgZmllbGRzVG9BZGQuc29ydChjb21wYXJlRmllbGRzVG9BZGQoaGFzU2VsZWN0ZWREaW1lbnNpb24sIGhhc1NlbGVjdGVkTWVhc3VyZSwgaW5kaWNlcykpO1xuXG4gIHZhciBzZXRzVG9BZGQgPSB1dGlsLmNob29zZUtvckxlc3MoZmllbGRzVG9BZGQsIDEpO1xuXG4gIHNldHNUb0FkZC5mb3JFYWNoKGZ1bmN0aW9uKHNldFRvQWRkKSB7XG4gICAgdmFyIGZpZWxkU2V0ID0gc2VsZWN0ZWQuY29uY2F0KHNldFRvQWRkKTtcbiAgICBpZiAoZmllbGRTZXQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9wdC5vbWl0RG90UGxvdCAmJiBmaWVsZFNldC5sZW5ndGggPT09IDEpIHJldHVybjtcbiAgICAgIGZpZWxkU2V0cy5wdXNoKGZpZWxkU2V0KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZpZWxkU2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkU2V0KSB7XG4gICAgICAvLyBhbHdheXMgYXBwZW5kIHByb2plY3Rpb24ncyBrZXkgdG8gZWFjaCBwcm9qZWN0aW9uIHJldHVybmVkLCBkMyBzdHlsZS5cbiAgICBmaWVsZFNldC5rZXkgPSBwcm9qZWN0aW9ucy5rZXkoZmllbGRTZXQpO1xuICB9KTtcblxuICByZXR1cm4gZmllbGRTZXRzO1xufVxuXG52YXIgdHlwZUlzTWVhc3VyZVNjb3JlID0ge1xuICBOOiAwLFxuICBPOiAxLFxuICBUOiAyLFxuICBROiAzXG59O1xuXG5mdW5jdGlvbiBjb21wYXJlRmllbGRzVG9BZGQoaGFzU2VsZWN0ZWREaW1lbnNpb24sIGhhc1NlbGVjdGVkTWVhc3VyZSwgaW5kaWNlcykge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgLy8gc29ydCBieSB0eXBlIG9mIHRoZSBkYXRhXG4gICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICBpZiAoIWhhc1NlbGVjdGVkRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlSXNNZWFzdXJlU2NvcmVbYS50eXBlXSAtIHR5cGVJc01lYXN1cmVTY29yZVtiLnR5cGVdO1xuICAgICAgfSBlbHNlIGlmICghaGFzU2VsZWN0ZWRNZWFzdXJlKSB7XG4gICAgICAgIHJldHVybiB0eXBlSXNNZWFzdXJlU2NvcmVbYi50eXBlXSAtIHR5cGVJc01lYXN1cmVTY29yZVthLnR5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgICAvL21ha2UgdGhlIHNvcnQgc3RhYmxlXG4gICAgcmV0dXJuIGluZGljZXNbYS5uYW1lXSAtIGluZGljZXNbYi5uYW1lXTtcbiAgfTtcbn1cblxucHJvamVjdGlvbnMua2V5ID0gZnVuY3Rpb24ocHJvamVjdGlvbikge1xuICByZXR1cm4gcHJvamVjdGlvbi5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICByZXR1cm4gdmwuZmllbGQuaXNDb3VudChmaWVsZCkgPyAnY291bnQnIDogZmllbGQubmFtZTtcbiAgfSkuam9pbignLCcpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZyA9IGdsb2JhbCB8fCB3aW5kb3c7XG5cbnJlcXVpcmUoJ3ZlZ2EtbGl0ZS9zcmMvZ2xvYmFscycpO1xuXG5nLkNIQVJUX1RZUEVTID0ge1xuICBUQUJMRTogJ1RBQkxFJyxcbiAgQkFSOiAnQkFSJyxcbiAgUExPVDogJ1BMT1QnLFxuICBMSU5FOiAnTElORScsXG4gIEFSRUE6ICdBUkVBJyxcbiAgTUFQOiAnTUFQJyxcbiAgSElTVE9HUkFNOiAnSElTVE9HUkFNJ1xufTtcblxuZy5BTllfREFUQV9UWVBFUyA9ICgxIDw8IDQpIC0gMTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2Rpbmc6IHJlcXVpcmUoJy4vcmFua0VuY29kaW5ncycpXG59O1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy52bCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudmwgOiBudWxsKSxcbiAgaXNEaW1lbnNpb24gPSB2bC5maWVsZC5pc0RpbWVuc2lvbjtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5rRW5jb2RpbmdzO1xuXG4vLyBiYWQgc2NvcmUgbm90IHNwZWNpZmllZCBpbiB0aGUgdGFibGUgYWJvdmVcbnZhciBVTlVTRURfUE9TSVRJT04gPSAwLjU7XG5cbnZhciBNQVJLX1NDT1JFID0ge1xuICBsaW5lOiAwLjk5LFxuICBhcmVhOiAwLjk4LFxuICBiYXI6IDAuOTcsXG4gIHRpY2s6IDAuOTYsXG4gIHBvaW50OiAwLjk1LFxuICBjaXJjbGU6IDAuOTQsXG4gIHNxdWFyZTogMC45NCxcbiAgdGV4dDogMC44XG59O1xuXG5mdW5jdGlvbiByYW5rRW5jb2RpbmdzKGVuY29kaW5nLCBzdGF0cywgb3B0LCBzZWxlY3RlZCkge1xuICB2YXIgZmVhdHVyZXMgPSBbXSxcbiAgICBlbmNUeXBlcyA9IHZsLmtleXMoZW5jb2RpbmcuZW5jb2RpbmcpLFxuICAgIG1hcmt0eXBlID0gZW5jb2RpbmcubWFya3R5cGUsXG4gICAgZW5jID0gZW5jb2RpbmcuZW5jb2Rpbmc7XG5cbiAgdmFyIGVuY29kaW5nTWFwcGluZ0J5RmllbGQgPSB2bC5lbmMucmVkdWNlKGVuY29kaW5nLmVuY29kaW5nLCBmdW5jdGlvbihvLCBmaWVsZCwgZW5jVHlwZSkge1xuICAgIHZhciBrZXkgPSB2bC5maWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICAgIHZhciBtYXBwaW5ncyA9IG9ba2V5XSA9IG9ba2V5XSB8fCBbXTtcbiAgICBtYXBwaW5ncy5wdXNoKHtlbmNUeXBlOiBlbmNUeXBlLCBmaWVsZDogZmllbGR9KTtcbiAgICByZXR1cm4gbztcbiAgfSwge30pO1xuXG4gIC8vIGRhdGEgLSBlbmNvZGluZyBtYXBwaW5nIHNjb3JlXG4gIHZsLmZvckVhY2goZW5jb2RpbmdNYXBwaW5nQnlGaWVsZCwgZnVuY3Rpb24obWFwcGluZ3MpIHtcbiAgICB2YXIgcmVhc29ucyA9IG1hcHBpbmdzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBtLmVuY1R5cGUgKyB2bC5zaG9ydGhhbmQuYXNzaWduICsgdmwuZmllbGQuc2hvcnRoYW5kKG0uZmllbGQpICtcbiAgICAgICAgICAnICcgKyAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWRbbS5maWVsZC5uYW1lXSA/ICdbeF0nIDogJ1sgXScpO1xuICAgICAgfSksXG4gICAgICBzY29yZXMgPSBtYXBwaW5ncy5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgcm9sZSA9IHZsLmZpZWxkLnJvbGUobS5maWVsZCk7XG4gICAgICAgIHZhciBzY29yZSA9IHJhbmtFbmNvZGluZ3Muc2NvcmVbcm9sZV0obS5maWVsZCwgbS5lbmNUeXBlLCBlbmNvZGluZy5tYXJrdHlwZSwgc3RhdHMsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuICFzZWxlY3RlZCB8fCBzZWxlY3RlZFttLmZpZWxkLm5hbWVdID8gc2NvcmUgOiBNYXRoLnBvdyhzY29yZSwgMC4xMjUpO1xuICAgICAgfSk7XG5cbiAgICBmZWF0dXJlcy5wdXNoKHtcbiAgICAgIHJlYXNvbjogcmVhc29ucy5qb2luKFwiIHwgXCIpLFxuICAgICAgc2NvcmU6IE1hdGgubWF4LmFwcGx5KG51bGwsIHNjb3JlcylcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gcGxvdCB0eXBlXG4gIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkge1xuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5jLnggJiYgZW5jLnkpIHtcbiAgICAgIGlmIChpc0RpbWVuc2lvbihlbmMueCkgXiBpc0RpbWVuc2lvbihlbmMueSkpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgcmVhc29uOiAnT3hRIHBsb3QnLFxuICAgICAgICAgIHNjb3JlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcGVuYWxpemUgbm90IHVzaW5nIHBvc2l0aW9uYWwgb25seSBwZW5hbGl6ZSBmb3Igbm9uLXRleHRcbiAgaWYgKGVuY1R5cGVzLmxlbmd0aCA+IDEgJiYgbWFya3R5cGUgIT09IFRFWFQpIHtcbiAgICBpZiAoKCFlbmMueCB8fCAhZW5jLnkpICYmICFlbmMuZ2VvICYmICFlbmMudGV4dCkge1xuICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHJlYXNvbjogJ3VudXNlZCBwb3NpdGlvbicsXG4gICAgICAgIHNjb3JlOiBVTlVTRURfUE9TSVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1hcmsgdHlwZSBzY29yZVxuICBmZWF0dXJlcy5wdXNoKHtcbiAgICByZWFzb246ICdtYXJrdHlwZT0nK21hcmt0eXBlLFxuICAgIHNjb3JlOiBNQVJLX1NDT1JFW21hcmt0eXBlXVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNjb3JlOiBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24ocCwgZikge1xuICAgICAgcmV0dXJuIHAgKiBmLnNjb3JlO1xuICAgIH0sIDEpLFxuICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICB9O1xufVxuXG5cbnZhciBEID0ge30sIE0gPSB7fSwgQkFEID0gMC4xLCBURVJSSUJMRSA9IDAuMDE7XG5cbkQubWlub3IgPSAwLjAxO1xuRC5wb3MgPSAxO1xuRC5ZX1QgPSAwLjg7XG5ELmZhY2V0X3RleHQgPSAxO1xuRC5mYWNldF9nb29kID0gMC42NzU7IC8vIDwgY29sb3Jfb2ssID4gY29sb3JfYmFkXG5ELmZhY2V0X29rID0gMC41NTtcbkQuZmFjZXRfYmFkID0gMC40O1xuRC5jb2xvcl9nb29kID0gMC43O1xuRC5jb2xvcl9vayA9IDAuNjU7IC8vID4gTS5TaXplXG5ELmNvbG9yX2JhZCA9IDAuMztcbkQuY29sb3Jfc3RhY2sgPSAwLjY7XG5ELnNoYXBlID0gMC42O1xuRC5kZXRhaWwgPSAwLjU7XG5ELmJhZCA9IEJBRDtcbkQudGVycmlibGUgPSBURVJSSUJMRTtcblxuTS5wb3MgPSAxO1xuTS5zaXplID0gMC42O1xuTS5jb2xvciA9IDAuNTtcbk0uYWxwaGEgPSAwLjQ1O1xuTS50ZXh0ID0gMC40O1xuTS5iYWQgPSBCQUQ7XG5NLnRlcnJpYmxlID0gVEVSUklCTEU7XG5cbnJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUgPSBmdW5jdGlvbiAoZmllbGQsIGVuY1R5cGUsIG1hcmt0eXBlLCBzdGF0cywgb3B0KXtcbiAgdmFyIGNhcmRpbmFsaXR5ID0gdmwuZmllbGQuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKTtcbiAgc3dpdGNoIChlbmNUeXBlKSB7XG4gICAgY2FzZSBYOlxuICAgICAgaWYgKHZsLmZpZWxkLmlzVHlwZXMoZmllbGQsIFtOLCBPXSkpICByZXR1cm4gRC5wb3MgLSBELm1pbm9yO1xuICAgICAgcmV0dXJuIEQucG9zO1xuXG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHZsLmZpZWxkLmlzVHlwZXMoZmllbGQsIFtOLCBPXSkpIHJldHVybiBELnBvcyAtIEQubWlub3I7IC8vcHJlZmVyIG9yZGluYWwgb24geVxuICAgICAgaWYoZmllbGQudHlwZSA9PT0gVCkgcmV0dXJuIEQuWV9UOyAvLyB0aW1lIHNob3VsZCBub3QgYmUgb24gWVxuICAgICAgcmV0dXJuIEQucG9zIC0gRC5taW5vcjtcblxuICAgIGNhc2UgQ09MOlxuICAgICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSByZXR1cm4gRC5mYWNldF90ZXh0O1xuICAgICAgLy9wcmVmZXIgY29sdW1uIG92ZXIgcm93IGR1ZSB0byBzY3JvbGxpbmcgaXNzdWVzXG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfZ29vZCA6XG4gICAgICAgIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfb2sgOiBELmZhY2V0X2JhZDtcblxuICAgIGNhc2UgUk9XOlxuICAgICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSByZXR1cm4gRC5mYWNldF90ZXh0O1xuICAgICAgcmV0dXJuIChjYXJkaW5hbGl0eSA8PSBvcHQubWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9nb29kIDpcbiAgICAgICAgY2FyZGluYWxpdHkgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yRmFjZXRzID8gRC5mYWNldF9vayA6IEQuZmFjZXRfYmFkKSAtIEQubWlub3I7XG5cbiAgICBjYXNlIENPTE9SOlxuICAgICAgdmFyIGhhc09yZGVyID0gKGZpZWxkLmJpbiAmJiBmaWVsZC50eXBlPT09USkgfHwgKGZpZWxkLmZuICYmIGZpZWxkLnR5cGU9PT1UKTtcblxuICAgICAgLy9GSVhNRSBhZGQgc3RhY2tpbmcgb3B0aW9uIG9uY2Ugd2UgaGF2ZSBjb250cm9sIC4uXG4gICAgICB2YXIgaXNTdGFja2VkID0gbWFya3R5cGUgPT09ICdiYXInIHx8IG1hcmt0eXBlID09PSAnYXJlYSc7XG5cbiAgICAgIC8vIHRydWUgb3JkaW5hbCBvbiBjb2xvciBpcyBjdXJyZW50bHkgQkFEICh1bnRpbCB3ZSBoYXZlIGdvb2Qgb3JkaW5hbCBjb2xvciBzY2FsZSBzdXBwb3J0KVxuICAgICAgaWYgKGhhc09yZGVyKSByZXR1cm4gRC5jb2xvcl9iYWQ7XG5cbiAgICAgIC8vc3RhY2tpbmcgZ2V0cyBsb3dlciBzY29yZVxuICAgICAgaWYgKGlzU3RhY2tlZCkgcmV0dXJuIEQuY29sb3Jfc3RhY2s7XG5cbiAgICAgIHJldHVybiBjYXJkaW5hbGl0eSA8PSBvcHQubWF4R29vZENhcmRpbmFsaXR5Rm9yQ29sb3IgPyBELmNvbG9yX2dvb2Q6IGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckNvbG9yID8gRC5jb2xvcl9vayA6IEQuY29sb3JfYmFkO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yU2hhcGUgPyBELnNoYXBlIDogVEVSUklCTEU7XG4gICAgY2FzZSBERVRBSUw6XG4gICAgICByZXR1cm4gRC5kZXRhaWw7XG4gIH1cbiAgcmV0dXJuIFRFUlJJQkxFO1xufTtcblxucmFua0VuY29kaW5ncy5kaW1lbnNpb25TY29yZS5jb25zdHMgPSBEO1xuXG5yYW5rRW5jb2RpbmdzLm1lYXN1cmVTY29yZSA9IGZ1bmN0aW9uIChmaWVsZCwgZW5jVHlwZSwgbWFya3R5cGUsIHN0YXRzLCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICBzd2l0Y2ggKGVuY1R5cGUpe1xuICAgIGNhc2UgWDogcmV0dXJuIE0ucG9zO1xuICAgIGNhc2UgWTogcmV0dXJuIE0ucG9zO1xuICAgIGNhc2UgU0laRTpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gJ2JhcicpIHJldHVybiBCQUQ7IC8vc2l6ZSBvZiBiYXIgaXMgdmVyeSBiYWRcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkgcmV0dXJuIEJBRDtcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gJ2xpbmUnKSByZXR1cm4gQkFEO1xuICAgICAgcmV0dXJuIE0uc2l6ZTtcbiAgICBjYXNlIENPTE9SOiByZXR1cm4gTS5jb2xvcjtcbiAgICBjYXNlICdhbHBoYSc6IHJldHVybiBNLmFscGhhO1xuICAgIGNhc2UgVEVYVDogcmV0dXJuIE0udGV4dDtcbiAgfVxuICByZXR1cm4gQkFEO1xufTtcblxucmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUuY29uc3RzID0gTTtcblxuXG5yYW5rRW5jb2RpbmdzLnNjb3JlID0ge1xuICBkaW1lbnNpb246IHJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUsXG4gIG1lYXN1cmU6IHJhbmtFbmNvZGluZ3MubWVhc3VyZVNjb3JlLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2VuOiB7fVxufTtcblxudXRpbC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnV0aWwuanNvbiA9IGZ1bmN0aW9uKHMsIHNwKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzLCBudWxsLCBzcCk7XG59O1xuXG51dGlsLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGsgPSBbXSwgeDtcbiAgZm9yICh4IGluIG9iaikgay5wdXNoKHgpO1xuICByZXR1cm4gaztcbn07XG5cbnV0aWwubmVzdGVkTWFwID0gZnVuY3Rpb24gKGNvbCwgZiwgbGV2ZWwsIGZpbHRlcikge1xuICByZXR1cm4gbGV2ZWwgPT09IDAgP1xuICAgIGNvbC5tYXAoZikgOlxuICAgIGNvbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgdmFyIHIgPSB1dGlsLm5lc3RlZE1hcCh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKHV0aWwubm9uRW1wdHkpIDogcjtcbiAgICB9KTtcbn07XG5cbnV0aWwubmVzdGVkUmVkdWNlID0gZnVuY3Rpb24gKGNvbCwgZiwgbGV2ZWwsIGZpbHRlcikge1xuICByZXR1cm4gbGV2ZWwgPT09IDAgP1xuICAgIGNvbC5yZWR1Y2UoZiwgW10pIDpcbiAgICBjb2wubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciByID0gdXRpbC5uZXN0ZWRSZWR1Y2UodiwgZiwgbGV2ZWwgLSAxKTtcbiAgICAgIHJldHVybiBmaWx0ZXIgPyByLmZpbHRlcih1dGlsLm5vbkVtcHR5KSA6IHI7XG4gICAgfSk7XG59O1xuXG51dGlsLm5vbkVtcHR5ID0gZnVuY3Rpb24oZ3JwKSB7XG4gIHJldHVybiAhdXRpbC5pc0FycmF5KGdycCkgfHwgZ3JwLmxlbmd0aCA+IDA7XG59O1xuXG5cbnV0aWwudHJhdmVyc2UgPSBmdW5jdGlvbiAobm9kZSwgYXJyKSB7XG4gIGlmIChub2RlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBhcnIucHVzaChub2RlLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobm9kZS5sZWZ0KSB1dGlsLnRyYXZlcnNlKG5vZGUubGVmdCwgYXJyKTtcbiAgICBpZiAobm9kZS5yaWdodCkgdXRpbC50cmF2ZXJzZShub2RlLnJpZ2h0LCBhcnIpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG51dGlsLnVuaW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIG8gPSB7fTtcbiAgYS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgb1t4XSA9IHRydWU7fSk7XG4gIGIuZm9yRWFjaChmdW5jdGlvbih4KSB7IG9beF0gPSB0cnVlO30pO1xuICByZXR1cm4gdXRpbC5rZXlzKG8pO1xufTtcblxuXG51dGlsLmdlbi5nZXRPcHQgPSBmdW5jdGlvbiAob3B0KSB7XG4gIC8vbWVyZ2Ugd2l0aCBkZWZhdWx0XG4gIHJldHVybiAob3B0ID8gdXRpbC5rZXlzKG9wdCkgOiBbXSkucmVkdWNlKGZ1bmN0aW9uKGMsIGspIHtcbiAgICBjW2tdID0gb3B0W2tdO1xuICAgIHJldHVybiBjO1xuICB9LCBPYmplY3QuY3JlYXRlKGNvbnN0cy5nZW4uREVGQVVMVF9PUFQpKTtcbn07XG5cbi8qKlxuICogcG93ZXJzZXQgY29kZSBmcm9tIGh0dHA6Ly9yb3NldHRhY29kZS5vcmcvd2lraS9Qb3dlcl9TZXQjSmF2YVNjcmlwdFxuICpcbiAqICAgdmFyIHJlcyA9IHBvd2Vyc2V0KFsxLDIsMyw0XSk7XG4gKlxuICogcmV0dXJuc1xuICpcbiAqIFtbXSxbMV0sWzJdLFsxLDJdLFszXSxbMSwzXSxbMiwzXSxbMSwyLDNdLFs0XSxbMSw0XSxcbiAqIFsyLDRdLFsxLDIsNF0sWzMsNF0sWzEsMyw0XSxbMiwzLDRdLFsxLDIsMyw0XV1cbltlZGl0XVxuKi9cblxudXRpbC5wb3dlcnNldCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgdmFyIHBzID0gW1xuICAgIFtdXG4gIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBwcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgcHMucHVzaChwc1tqXS5jb25jYXQobGlzdFtpXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHM7XG59O1xuXG51dGlsLmNob29zZUtvckxlc3MgPSBmdW5jdGlvbihsaXN0LCBrKSB7XG4gIHZhciBzdWJzZXQgPSBbW11dO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gc3Vic2V0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgc3ViID0gc3Vic2V0W2pdLmNvbmNhdChsaXN0W2ldKTtcbiAgICAgIGlmKHN1Yi5sZW5ndGggPD0gayl7XG4gICAgICAgIHN1YnNldC5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJzZXQ7XG59O1xuXG51dGlsLmNob29zZUsgPSBmdW5jdGlvbihsaXN0LCBrKSB7XG4gIHZhciBzdWJzZXQgPSBbW11dO1xuICB2YXIga0FycmF5ID1bXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHN1YnNldC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHN1YiA9IHN1YnNldFtqXS5jb25jYXQobGlzdFtpXSk7XG4gICAgICBpZihzdWIubGVuZ3RoIDwgayl7XG4gICAgICAgIHN1YnNldC5wdXNoKHN1Yik7XG4gICAgICB9ZWxzZSBpZiAoc3ViLmxlbmd0aCA9PT0gayl7XG4gICAgICAgIGtBcnJheS5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBrQXJyYXk7XG59O1xuXG51dGlsLmNyb3NzID0gZnVuY3Rpb24oYSxiKXtcbiAgdmFyIHggPSBbXTtcbiAgZm9yKHZhciBpPTA7IGk8IGEubGVuZ3RoOyBpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8IGIubGVuZ3RoOyBqKyspe1xuICAgICAgeC5wdXNoKGFbaV0uY29uY2F0KGJbal0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4iXX0=\n","module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};","module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};","var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n","var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2.score - encoding1.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0].score - cluster1[0].score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}","'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['color', 'alpha', c.SWAPPABLE],\n  ['size', 'alpha', c.SWAPPABLE],\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.encoding.color.name !== colenc2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.encoding;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    encoding: encoding.encoding\n  };\n};","'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'avg']\n    },\n    timeFnList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, alpha, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null);\n\nvar consts = require('../consts');\n\nvar ANY='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasNorO = vl.any(fields, function(f) {\n    return vl.field.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.field.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.field.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.field.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === ANY || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [ANY, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.field.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [ANY, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [ANY, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignFnT(i, hasAggr, autoMode, fn) {\n    tf[i].fn = fn;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].fn;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._fns\n    if (f._fn) {\n      assignFnT(i, hasAggr, autoMode, f._fn);\n    } else {\n      opt.timeFnList.forEach(function(fn) {\n        if (fn === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignFnT(i, hasAggr, autoMode, fn);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, ANY);\n\n  return output;\n}\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          data: opt.data,\n          marktype: markType,\n          encoding: enc,\n          config: opt.config\n        }),\n        encoding = finalTouch(e, stats, opt),\n        score = rank.encoding(encoding, stats, opt);\n\n      encoding.score = score.score;\n      encoding.scoreFeatures = score.features;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.encoding.color = encoding.encoding.text;\n  }\n\n  // don't include zero if stdev/avg < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.encoding;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.field.isMeasure(field) && !vl.field.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.avg < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}","\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.field.isDimension,\n  isMeasure = vl.field.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  alpha: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape || enc.alpha) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.field.isMeasure(field) ||\n    vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === Q) return false;\n  if (field.fn && field.type === T) return false;\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (vl.field.isTypes(enc.y, [N, O]) && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (!vl.field.isTypes(enc.x, [N, O]) && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type===T || enc.x.type === T) {\n          if (enc.y.type===T && enc.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // one dimension \"count\" is useless\n    if (enc.x && enc.x.aggregate == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggregate == 'count' && !enc.x) return false;\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.field.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n","'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};","\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  consts = require('../consts'),\n  isDimension = vl.field.isDimension,\n  isOrdinalScale = vl.field.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n\n  var markTypes = opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n\n  return markTypes;\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compile.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.field.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // need to aggregate on either x or y\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  if (((enc.x.aggregate !== undefined) ^ (enc.y.aggregate !== undefined)) &&\n      (isDimension(enc.x) ^ isDimension(enc.y))) {\n\n    var aggregate = enc.x.aggregate || enc.y.aggregate;\n    return !(opt.omitStackedAverage && aggregate ==='avg' && enc.color);\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.fn && enc.y.type == 'Q' && enc.y.aggregate;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggregate ==='avg' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggregate && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}","'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.field.isCount(field)) {\n      if (vl.field.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.field.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 1,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.field.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n","'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;","module.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n","'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window.vl : typeof global !== \"undefined\" ? global.vl : null),\n  isDimension = vl.field.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.encoding),\n    marktype = encoding.marktype,\n    enc = encoding.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.encoding, function(o, field, encType) {\n    var key = vl.field.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.field.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.field.role(m.field);\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.alpha = 0.45;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.field.cardinality(field, stats);\n  switch (encType) {\n    case X:\n      if (vl.field.isTypes(field, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.field.isTypes(field, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (field.bin && field.type===Q) || (field.fn && field.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case 'alpha': return M.alpha;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n","\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n"],"sourceRoot":"/source/"}